// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: greenfield/sp/types.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Status is the status of a storage provider.
type Status int32

const (
	STATUS_IN_SERVICE       Status = 0
	STATUS_IN_JAILED        Status = 1
	STATUS_GRACEFUL_EXITING Status = 2
	STATUS_IN_MAINTENANCE   Status = 3
	STATUS_FORCE_EXITING    Status = 4
)

var Status_name = map[int32]string{
	0: "STATUS_IN_SERVICE",
	1: "STATUS_IN_JAILED",
	2: "STATUS_GRACEFUL_EXITING",
	3: "STATUS_IN_MAINTENANCE",
	4: "STATUS_FORCE_EXITING",
}

var Status_value = map[string]int32{
	"STATUS_IN_SERVICE":       0,
	"STATUS_IN_JAILED":        1,
	"STATUS_GRACEFUL_EXITING": 2,
	"STATUS_IN_MAINTENANCE":   3,
	"STATUS_FORCE_EXITING":    4,
}

func (x Status) String() string {
	return proto.EnumName(Status_name, int32(x))
}

func (Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7a9af9b5be8c2eeb, []int{0}
}

// Description defines a storage provider description.
type Description struct {
	// moniker defines a human-readable name for the storage provider
	Moniker string `protobuf:"bytes,1,opt,name=moniker,proto3" json:"moniker,omitempty"`
	// identity defines an optional identity signature (ex. UPort or Keybase).
	Identity string `protobuf:"bytes,2,opt,name=identity,proto3" json:"identity,omitempty"`
	// website defines an optional website link.
	Website string `protobuf:"bytes,3,opt,name=website,proto3" json:"website,omitempty"`
	// security_contact defines an optional email for security contact.
	SecurityContact string `protobuf:"bytes,4,opt,name=security_contact,json=securityContact,proto3" json:"security_contact,omitempty"`
	// details define other optional details.
	Details string `protobuf:"bytes,5,opt,name=details,proto3" json:"details,omitempty"`
}

func (m *Description) Reset()         { *m = Description{} }
func (m *Description) String() string { return proto.CompactTextString(m) }
func (*Description) ProtoMessage()    {}
func (*Description) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a9af9b5be8c2eeb, []int{0}
}
func (m *Description) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Description) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Description.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Description) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Description.Merge(m, src)
}
func (m *Description) XXX_Size() int {
	return m.Size()
}
func (m *Description) XXX_DiscardUnknown() {
	xxx_messageInfo_Description.DiscardUnknown(m)
}

var xxx_messageInfo_Description proto.InternalMessageInfo

func (m *Description) GetMoniker() string {
	if m != nil {
		return m.Moniker
	}
	return ""
}

func (m *Description) GetIdentity() string {
	if m != nil {
		return m.Identity
	}
	return ""
}

func (m *Description) GetWebsite() string {
	if m != nil {
		return m.Website
	}
	return ""
}

func (m *Description) GetSecurityContact() string {
	if m != nil {
		return m.SecurityContact
	}
	return ""
}

func (m *Description) GetDetails() string {
	if m != nil {
		return m.Details
	}
	return ""
}

// StorageProvider defines the meta info of storage provider
type StorageProvider struct {
	// // id is the identifier of the storage provider, used in virtual group
	Id uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// operator_address defines the account address of the storage provider's operator; It also is the unique index key of sp.
	OperatorAddress string `protobuf:"bytes,2,opt,name=operator_address,json=operatorAddress,proto3" json:"operator_address,omitempty"`
	// funding_address defines one of the storage provider's accounts which is used to deposit and reward.
	FundingAddress string `protobuf:"bytes,3,opt,name=funding_address,json=fundingAddress,proto3" json:"funding_address,omitempty"`
	// seal_address defines one of the storage provider's accounts which is used to SealObject
	SealAddress string `protobuf:"bytes,4,opt,name=seal_address,json=sealAddress,proto3" json:"seal_address,omitempty"`
	// approval_address defines one of the storage provider's accounts which is used to approve use's createBucket/createObject request
	ApprovalAddress string `protobuf:"bytes,5,opt,name=approval_address,json=approvalAddress,proto3" json:"approval_address,omitempty"`
	// gc_address defines one of the storage provider's accounts which is used for gc purpose.
	GcAddress string `protobuf:"bytes,6,opt,name=gc_address,json=gcAddress,proto3" json:"gc_address,omitempty"`
	// maintenance_address defines one of the storage provider's accounts which is used for testing while in maintenance mode
	MaintenanceAddress string `protobuf:"bytes,7,opt,name=maintenance_address,json=maintenanceAddress,proto3" json:"maintenance_address,omitempty"`
	// total_deposit defines the number of tokens deposited by this storage provider for staking.
	TotalDeposit github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,8,opt,name=total_deposit,json=totalDeposit,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"total_deposit"`
	// status defines the current service status of this storage provider
	Status Status `protobuf:"varint,9,opt,name=status,proto3,enum=greenfield.sp.Status" json:"status,omitempty"`
	// endpoint define the storage provider's network service address
	Endpoint string `protobuf:"bytes,10,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	// description defines the description terms for the storage provider.
	Description Description `protobuf:"bytes,11,opt,name=description,proto3" json:"description"`
	// bls_key defines the bls pub key of the Storage provider for sealing object and completing migration
	BlsKey []byte `protobuf:"bytes,12,opt,name=bls_key,json=blsKey,proto3" json:"bls_key,omitempty"`
}

func (m *StorageProvider) Reset()         { *m = StorageProvider{} }
func (m *StorageProvider) String() string { return proto.CompactTextString(m) }
func (*StorageProvider) ProtoMessage()    {}
func (*StorageProvider) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a9af9b5be8c2eeb, []int{1}
}
func (m *StorageProvider) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StorageProvider) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StorageProvider.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StorageProvider) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageProvider.Merge(m, src)
}
func (m *StorageProvider) XXX_Size() int {
	return m.Size()
}
func (m *StorageProvider) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageProvider.DiscardUnknown(m)
}

var xxx_messageInfo_StorageProvider proto.InternalMessageInfo

func (m *StorageProvider) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *StorageProvider) GetOperatorAddress() string {
	if m != nil {
		return m.OperatorAddress
	}
	return ""
}

func (m *StorageProvider) GetFundingAddress() string {
	if m != nil {
		return m.FundingAddress
	}
	return ""
}

func (m *StorageProvider) GetSealAddress() string {
	if m != nil {
		return m.SealAddress
	}
	return ""
}

func (m *StorageProvider) GetApprovalAddress() string {
	if m != nil {
		return m.ApprovalAddress
	}
	return ""
}

func (m *StorageProvider) GetGcAddress() string {
	if m != nil {
		return m.GcAddress
	}
	return ""
}

func (m *StorageProvider) GetMaintenanceAddress() string {
	if m != nil {
		return m.MaintenanceAddress
	}
	return ""
}

func (m *StorageProvider) GetStatus() Status {
	if m != nil {
		return m.Status
	}
	return STATUS_IN_SERVICE
}

func (m *StorageProvider) GetEndpoint() string {
	if m != nil {
		return m.Endpoint
	}
	return ""
}

func (m *StorageProvider) GetDescription() Description {
	if m != nil {
		return m.Description
	}
	return Description{}
}

func (m *StorageProvider) GetBlsKey() []byte {
	if m != nil {
		return m.BlsKey
	}
	return nil
}

type RewardInfo struct {
	Address string     `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Amount  types.Coin `protobuf:"bytes,2,opt,name=amount,proto3" json:"amount"`
}

func (m *RewardInfo) Reset()         { *m = RewardInfo{} }
func (m *RewardInfo) String() string { return proto.CompactTextString(m) }
func (*RewardInfo) ProtoMessage()    {}
func (*RewardInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a9af9b5be8c2eeb, []int{2}
}
func (m *RewardInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RewardInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RewardInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RewardInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RewardInfo.Merge(m, src)
}
func (m *RewardInfo) XXX_Size() int {
	return m.Size()
}
func (m *RewardInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_RewardInfo.DiscardUnknown(m)
}

var xxx_messageInfo_RewardInfo proto.InternalMessageInfo

func (m *RewardInfo) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *RewardInfo) GetAmount() types.Coin {
	if m != nil {
		return m.Amount
	}
	return types.Coin{}
}

// storage price of a specific sp
type SpStoragePrice struct {
	// sp id
	SpId uint32 `protobuf:"varint,1,opt,name=sp_id,json=spId,proto3" json:"sp_id,omitempty"`
	// update time, unix timestamp in seconds
	UpdateTimeSec int64 `protobuf:"varint,2,opt,name=update_time_sec,json=updateTimeSec,proto3" json:"update_time_sec,omitempty"`
	// read price, in bnb wei per charge byte
	ReadPrice github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,3,opt,name=read_price,json=readPrice,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"read_price"`
	// free read quota, in byte
	FreeReadQuota uint64 `protobuf:"varint,4,opt,name=free_read_quota,json=freeReadQuota,proto3" json:"free_read_quota,omitempty"`
	// store price, in bnb wei per charge byte
	StorePrice github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,5,opt,name=store_price,json=storePrice,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"store_price"`
}

func (m *SpStoragePrice) Reset()         { *m = SpStoragePrice{} }
func (m *SpStoragePrice) String() string { return proto.CompactTextString(m) }
func (*SpStoragePrice) ProtoMessage()    {}
func (*SpStoragePrice) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a9af9b5be8c2eeb, []int{3}
}
func (m *SpStoragePrice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpStoragePrice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpStoragePrice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpStoragePrice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpStoragePrice.Merge(m, src)
}
func (m *SpStoragePrice) XXX_Size() int {
	return m.Size()
}
func (m *SpStoragePrice) XXX_DiscardUnknown() {
	xxx_messageInfo_SpStoragePrice.DiscardUnknown(m)
}

var xxx_messageInfo_SpStoragePrice proto.InternalMessageInfo

func (m *SpStoragePrice) GetSpId() uint32 {
	if m != nil {
		return m.SpId
	}
	return 0
}

func (m *SpStoragePrice) GetUpdateTimeSec() int64 {
	if m != nil {
		return m.UpdateTimeSec
	}
	return 0
}

func (m *SpStoragePrice) GetFreeReadQuota() uint64 {
	if m != nil {
		return m.FreeReadQuota
	}
	return 0
}

// global sp store price, the price for all sps
type GlobalSpStorePrice struct {
	// update time, unix timestamp in seconds
	UpdateTimeSec int64 `protobuf:"varint,1,opt,name=update_time_sec,json=updateTimeSec,proto3" json:"update_time_sec,omitempty"`
	// read price, in bnb wei per charge byte
	ReadPrice github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,2,opt,name=read_price,json=readPrice,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"read_price"`
	// primary store price, in bnb wei per charge byte
	PrimaryStorePrice github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,3,opt,name=primary_store_price,json=primaryStorePrice,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"primary_store_price"`
	// secondary store price, in bnb wei per charge byte
	SecondaryStorePrice github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,4,opt,name=secondary_store_price,json=secondaryStorePrice,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"secondary_store_price"`
}

func (m *GlobalSpStorePrice) Reset()         { *m = GlobalSpStorePrice{} }
func (m *GlobalSpStorePrice) String() string { return proto.CompactTextString(m) }
func (*GlobalSpStorePrice) ProtoMessage()    {}
func (*GlobalSpStorePrice) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a9af9b5be8c2eeb, []int{4}
}
func (m *GlobalSpStorePrice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalSpStorePrice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GlobalSpStorePrice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GlobalSpStorePrice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalSpStorePrice.Merge(m, src)
}
func (m *GlobalSpStorePrice) XXX_Size() int {
	return m.Size()
}
func (m *GlobalSpStorePrice) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalSpStorePrice.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalSpStorePrice proto.InternalMessageInfo

func (m *GlobalSpStorePrice) GetUpdateTimeSec() int64 {
	if m != nil {
		return m.UpdateTimeSec
	}
	return 0
}

type SpMaintenanceStats struct {
	Records []*MaintenanceRecord `protobuf:"bytes,1,rep,name=records,proto3" json:"records,omitempty"`
}

func (m *SpMaintenanceStats) Reset()         { *m = SpMaintenanceStats{} }
func (m *SpMaintenanceStats) String() string { return proto.CompactTextString(m) }
func (*SpMaintenanceStats) ProtoMessage()    {}
func (*SpMaintenanceStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a9af9b5be8c2eeb, []int{5}
}
func (m *SpMaintenanceStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpMaintenanceStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpMaintenanceStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpMaintenanceStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpMaintenanceStats.Merge(m, src)
}
func (m *SpMaintenanceStats) XXX_Size() int {
	return m.Size()
}
func (m *SpMaintenanceStats) XXX_DiscardUnknown() {
	xxx_messageInfo_SpMaintenanceStats.DiscardUnknown(m)
}

var xxx_messageInfo_SpMaintenanceStats proto.InternalMessageInfo

func (m *SpMaintenanceStats) GetRecords() []*MaintenanceRecord {
	if m != nil {
		return m.Records
	}
	return nil
}

// MaintenanceRecord is to keep track of every time a sp request to be in Maintenance mode
type MaintenanceRecord struct {
	// block height that request to be in Maintenance mode
	Height int64 `protobuf:"varint,1,opt,name=height,proto3" json:"height,omitempty"`
	// request duration
	RequestDuration int64 `protobuf:"varint,2,opt,name=request_duration,json=requestDuration,proto3" json:"request_duration,omitempty"`
	// actual duration
	ActualDuration int64 `protobuf:"varint,3,opt,name=actual_duration,json=actualDuration,proto3" json:"actual_duration,omitempty"`
	// request timestamp
	RequestAt int64 `protobuf:"varint,4,opt,name=request_at,json=requestAt,proto3" json:"request_at,omitempty"`
}

func (m *MaintenanceRecord) Reset()         { *m = MaintenanceRecord{} }
func (m *MaintenanceRecord) String() string { return proto.CompactTextString(m) }
func (*MaintenanceRecord) ProtoMessage()    {}
func (*MaintenanceRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a9af9b5be8c2eeb, []int{6}
}
func (m *MaintenanceRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MaintenanceRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MaintenanceRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MaintenanceRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MaintenanceRecord.Merge(m, src)
}
func (m *MaintenanceRecord) XXX_Size() int {
	return m.Size()
}
func (m *MaintenanceRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_MaintenanceRecord.DiscardUnknown(m)
}

var xxx_messageInfo_MaintenanceRecord proto.InternalMessageInfo

func (m *MaintenanceRecord) GetHeight() int64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *MaintenanceRecord) GetRequestDuration() int64 {
	if m != nil {
		return m.RequestDuration
	}
	return 0
}

func (m *MaintenanceRecord) GetActualDuration() int64 {
	if m != nil {
		return m.ActualDuration
	}
	return 0
}

func (m *MaintenanceRecord) GetRequestAt() int64 {
	if m != nil {
		return m.RequestAt
	}
	return 0
}

func init() {
	proto.RegisterEnum("greenfield.sp.Status", Status_name, Status_value)
	proto.RegisterType((*Description)(nil), "greenfield.sp.Description")
	proto.RegisterType((*StorageProvider)(nil), "greenfield.sp.StorageProvider")
	proto.RegisterType((*RewardInfo)(nil), "greenfield.sp.RewardInfo")
	proto.RegisterType((*SpStoragePrice)(nil), "greenfield.sp.SpStoragePrice")
	proto.RegisterType((*GlobalSpStorePrice)(nil), "greenfield.sp.GlobalSpStorePrice")
	proto.RegisterType((*SpMaintenanceStats)(nil), "greenfield.sp.SpMaintenanceStats")
	proto.RegisterType((*MaintenanceRecord)(nil), "greenfield.sp.MaintenanceRecord")
}

func init() { proto.RegisterFile("greenfield/sp/types.proto", fileDescriptor_7a9af9b5be8c2eeb) }

var fileDescriptor_7a9af9b5be8c2eeb = []byte{
	// 1013 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0x41, 0x6f, 0x1b, 0x45,
	0x14, 0xf6, 0xda, 0x8e, 0xd3, 0x3c, 0x27, 0xb1, 0x33, 0x49, 0xe8, 0x26, 0x08, 0x37, 0xf2, 0x21,
	0x84, 0x4a, 0xb1, 0xd5, 0x70, 0xa8, 0x04, 0x5c, 0x1c, 0xdb, 0x8d, 0x16, 0xda, 0x50, 0xd6, 0x2e,
	0x42, 0x20, 0xb4, 0x1a, 0xef, 0xbe, 0x38, 0xa3, 0xd8, 0x33, 0xdb, 0x99, 0x71, 0x8a, 0xff, 0x01,
	0x17, 0x24, 0x7e, 0x01, 0x07, 0xf8, 0x05, 0x48, 0x3d, 0xf1, 0x0b, 0x7a, 0xac, 0x7a, 0x42, 0x1c,
	0x2a, 0x94, 0xfc, 0x0a, 0x6e, 0x68, 0x77, 0x67, 0xd7, 0x26, 0x1c, 0xac, 0x4a, 0x39, 0xd9, 0xef,
	0x7b, 0xef, 0xfb, 0xe6, 0xed, 0x9b, 0xf7, 0xde, 0x2e, 0xec, 0x0c, 0x25, 0x22, 0x3f, 0x63, 0x38,
	0x0a, 0x9a, 0x2a, 0x6c, 0xea, 0x69, 0x88, 0xaa, 0x11, 0x4a, 0xa1, 0x05, 0x59, 0x9b, 0xb9, 0x1a,
	0x2a, 0xdc, 0xad, 0xf9, 0x42, 0x8d, 0x85, 0x6a, 0x0e, 0xa8, 0xc2, 0xe6, 0xe5, 0x83, 0x01, 0x6a,
	0xfa, 0xa0, 0xe9, 0x0b, 0xc6, 0x93, 0xf0, 0xdd, 0x9d, 0xc4, 0xef, 0xc5, 0x56, 0x33, 0x31, 0x8c,
	0x6b, 0x6b, 0x28, 0x86, 0x22, 0xc1, 0xa3, 0x7f, 0x09, 0x5a, 0xff, 0xd5, 0x82, 0x72, 0x07, 0x95,
	0x2f, 0x59, 0xa8, 0x99, 0xe0, 0xc4, 0x86, 0xe5, 0xb1, 0xe0, 0xec, 0x02, 0xa5, 0x6d, 0xed, 0x59,
	0x07, 0x2b, 0x6e, 0x6a, 0x92, 0x5d, 0xb8, 0xc3, 0x02, 0xe4, 0x9a, 0xe9, 0xa9, 0x9d, 0x8f, 0x5d,
	0x99, 0x1d, 0xb1, 0x5e, 0xe0, 0x40, 0x31, 0x8d, 0x76, 0x21, 0x61, 0x19, 0x93, 0x7c, 0x04, 0x55,
	0x85, 0xfe, 0x44, 0x32, 0x3d, 0xf5, 0x7c, 0xc1, 0x35, 0xf5, 0xb5, 0x5d, 0x8c, 0x43, 0x2a, 0x29,
	0xde, 0x4e, 0xe0, 0x48, 0x24, 0x40, 0x4d, 0xd9, 0x48, 0xd9, 0x4b, 0x89, 0x88, 0x31, 0xeb, 0x7f,
	0x2c, 0x41, 0xa5, 0xa7, 0x85, 0xa4, 0x43, 0x7c, 0x2a, 0xc5, 0x25, 0x0b, 0x50, 0x92, 0x75, 0xc8,
	0xb3, 0x20, 0xce, 0x71, 0xcd, 0xcd, 0xb3, 0x80, 0xb4, 0xa1, 0x2a, 0x42, 0x94, 0x54, 0x0b, 0xe9,
	0xd1, 0x20, 0x90, 0xa8, 0x54, 0x92, 0xe6, 0xb1, 0xfd, 0xe6, 0xe5, 0xe1, 0x96, 0x29, 0x45, 0x2b,
	0xf1, 0xf4, 0xb4, 0x64, 0x7c, 0xe8, 0x56, 0x52, 0x86, 0x81, 0x49, 0x0b, 0x2a, 0x67, 0x13, 0x1e,
	0x30, 0x3e, 0xcc, 0x34, 0x0a, 0x0b, 0x34, 0xd6, 0x0d, 0x21, 0x95, 0xf8, 0x14, 0x56, 0x15, 0xd2,
	0x51, 0xc6, 0x2f, 0x2e, 0xe0, 0x97, 0xa3, 0xe8, 0x94, 0xdc, 0x86, 0x2a, 0x0d, 0x43, 0x29, 0x2e,
	0xe7, 0x04, 0x96, 0x16, 0x3d, 0x44, 0xca, 0x48, 0x45, 0x1e, 0x02, 0x0c, 0xfd, 0x8c, 0x5e, 0x5a,
	0x40, 0x5f, 0x19, 0xfa, 0x29, 0xd1, 0x81, 0xcd, 0x31, 0x65, 0x5c, 0x23, 0xa7, 0xdc, 0xc7, 0x4c,
	0x61, 0x79, 0x81, 0x02, 0x99, 0x23, 0xa5, 0x52, 0x14, 0xd6, 0xb4, 0xd0, 0x74, 0xe4, 0x05, 0x18,
	0x0a, 0xc5, 0xb4, 0x7d, 0x27, 0x16, 0xf9, 0xec, 0xd5, 0xdb, 0x7b, 0xb9, 0xbf, 0xde, 0xde, 0xdb,
	0x1f, 0x32, 0x7d, 0x3e, 0x19, 0x34, 0x7c, 0x31, 0x36, 0x4d, 0x6a, 0x7e, 0x0e, 0x55, 0x70, 0x61,
	0xfa, 0xdf, 0xe1, 0xfa, 0xcd, 0xcb, 0x43, 0x30, 0x47, 0x3a, 0x5c, 0xbb, 0xab, 0xb1, 0x64, 0x27,
	0x51, 0x24, 0x87, 0x50, 0x52, 0x9a, 0xea, 0x89, 0xb2, 0x57, 0xf6, 0xac, 0x83, 0xf5, 0xa3, 0xed,
	0xc6, 0x7f, 0x46, 0xa5, 0xd1, 0x8b, 0x9d, 0xae, 0x09, 0x8a, 0xda, 0x17, 0x79, 0x10, 0x0a, 0xc6,
	0xb5, 0x0d, 0x49, 0xfb, 0xa6, 0x36, 0x39, 0x86, 0x72, 0x30, 0x9b, 0x01, 0xbb, 0xbc, 0x67, 0x1d,
	0x94, 0x8f, 0x76, 0x6f, 0xe8, 0xcd, 0x4d, 0xc9, 0x71, 0x31, 0x7a, 0x0e, 0x77, 0x9e, 0x44, 0xee,
	0xc2, 0xf2, 0x60, 0xa4, 0xbc, 0x0b, 0x9c, 0xda, 0xab, 0x7b, 0xd6, 0xc1, 0xaa, 0x5b, 0x1a, 0x8c,
	0xd4, 0x17, 0x38, 0xad, 0x4f, 0x01, 0x5c, 0x7c, 0x41, 0x65, 0xe0, 0xf0, 0x33, 0x41, 0x8e, 0x60,
	0x39, 0xad, 0xab, 0xb5, 0xa0, 0xae, 0x69, 0x20, 0x79, 0x08, 0x25, 0x3a, 0x16, 0x13, 0xae, 0xe3,
	0x86, 0x2e, 0x1f, 0xed, 0x34, 0x4c, 0x7c, 0xb4, 0x05, 0x1a, 0x66, 0x0b, 0x34, 0xda, 0x82, 0xa5,
	0x89, 0x99, 0xf0, 0xfa, 0xef, 0x79, 0x58, 0xef, 0x85, 0xd9, 0xe4, 0x30, 0x1f, 0xc9, 0x26, 0x2c,
	0xa9, 0xd0, 0xcb, 0x26, 0xa7, 0xa8, 0x42, 0x27, 0x20, 0xfb, 0x50, 0x99, 0x84, 0x01, 0xd5, 0xe8,
	0x69, 0x36, 0x46, 0x4f, 0xa1, 0x1f, 0x9f, 0x54, 0x70, 0xd7, 0x12, 0xb8, 0xcf, 0xc6, 0xd8, 0x43,
	0x9f, 0x7c, 0x07, 0x20, 0x91, 0x06, 0x5e, 0x18, 0x49, 0x99, 0xc9, 0x78, 0x97, 0x2b, 0xed, 0xa0,
	0x3f, 0x77, 0xa5, 0x1d, 0xf4, 0xdd, 0x95, 0x48, 0x2f, 0xc9, 0x6c, 0x1f, 0x2a, 0x67, 0x12, 0xd1,
	0x8b, 0x4f, 0x78, 0x3e, 0x11, 0x9a, 0xc6, 0xb3, 0x53, 0x74, 0xd7, 0x22, 0xd8, 0x45, 0x1a, 0x7c,
	0x15, 0x81, 0xe4, 0x7b, 0x28, 0x2b, 0x2d, 0x24, 0x9a, 0x2c, 0x96, 0x6e, 0x21, 0x0b, 0x88, 0x05,
	0xe3, 0x34, 0xea, 0xff, 0xe4, 0x81, 0x9c, 0x8c, 0xc4, 0x80, 0x8e, 0x92, 0xca, 0x61, 0x96, 0xdd,
	0xcd, 0x12, 0x59, 0x8b, 0x4b, 0x94, 0xbf, 0xdd, 0x12, 0x8d, 0x60, 0x33, 0x94, 0x6c, 0x4c, 0xe5,
	0xd4, 0x9b, 0x2f, 0xc1, 0x6d, 0x5c, 0xc4, 0x86, 0x11, 0x9e, 0x7b, 0xe4, 0x10, 0xb6, 0x15, 0xfa,
	0x82, 0x07, 0x37, 0xcf, 0x2b, 0xde, 0xc2, 0x79, 0x9b, 0x99, 0xf4, 0xec, 0xc4, 0xfa, 0x53, 0x20,
	0xbd, 0xf0, 0xc9, 0x6c, 0x9b, 0x44, 0x23, 0xac, 0xc8, 0x27, 0xb0, 0x2c, 0xd1, 0x17, 0x32, 0x88,
	0x46, 0xa6, 0x70, 0x50, 0x3e, 0xda, 0xbb, 0x31, 0x99, 0x73, 0x0c, 0x37, 0x0e, 0x74, 0x53, 0x42,
	0xfd, 0x17, 0x0b, 0x36, 0xfe, 0xe7, 0x26, 0xef, 0x41, 0xe9, 0x1c, 0xd9, 0xf0, 0x5c, 0x9b, 0x3b,
	0x34, 0x56, 0xf4, 0xb2, 0x92, 0xf8, 0x7c, 0x82, 0x4a, 0x7b, 0xc1, 0x44, 0xd2, 0x78, 0x19, 0x24,
	0x83, 0x50, 0x31, 0x78, 0xc7, 0xc0, 0xe4, 0x43, 0xa8, 0x50, 0x5f, 0x4f, 0xa2, 0x0d, 0x97, 0x46,
	0x16, 0xe2, 0xc8, 0xf5, 0x04, 0xce, 0x02, 0x3f, 0x88, 0x1a, 0x22, 0xd1, 0xa4, 0xc9, 0xab, 0xaf,
	0x10, 0x5d, 0x69, 0x8c, 0xb4, 0xf4, 0xfd, 0x9f, 0x2c, 0x28, 0x25, 0x9b, 0x8a, 0x6c, 0xc3, 0x46,
	0xaf, 0xdf, 0xea, 0x3f, 0xeb, 0x79, 0xce, 0xa9, 0xd7, 0xeb, 0xba, 0x5f, 0x3b, 0xed, 0x6e, 0x35,
	0x47, 0xb6, 0xa0, 0x3a, 0x83, 0x3f, 0x6f, 0x39, 0x8f, 0xbb, 0x9d, 0xaa, 0x45, 0xde, 0x87, 0xbb,
	0x06, 0x3d, 0x71, 0x5b, 0xed, 0xee, 0xa3, 0x67, 0x8f, 0xbd, 0xee, 0x37, 0x4e, 0xdf, 0x39, 0x3d,
	0xa9, 0xe6, 0xc9, 0x0e, 0x6c, 0xcf, 0x28, 0x4f, 0x5a, 0xce, 0x69, 0xbf, 0x7b, 0xda, 0x3a, 0x6d,
	0x77, 0xab, 0x05, 0x62, 0xc3, 0x96, 0x71, 0x3d, 0xfa, 0xd2, 0x6d, 0x77, 0x33, 0x52, 0x71, 0xb7,
	0xf8, 0xe3, 0x6f, 0xb5, 0xdc, 0x71, 0xe7, 0xd5, 0x55, 0xcd, 0x7a, 0x7d, 0x55, 0xb3, 0xfe, 0xbe,
	0xaa, 0x59, 0x3f, 0x5f, 0xd7, 0x72, 0xaf, 0xaf, 0x6b, 0xb9, 0x3f, 0xaf, 0x6b, 0xb9, 0x6f, 0xef,
	0xcf, 0xdd, 0xf3, 0x80, 0x0f, 0x0e, 0xfd, 0x73, 0xca, 0x78, 0x73, 0xee, 0xcb, 0xe5, 0x87, 0xec,
	0xdb, 0x65, 0x50, 0x8a, 0x3f, 0x2e, 0x3e, 0xfe, 0x37, 0x00, 0x00, 0xff, 0xff, 0x72, 0xdf, 0x0b,
	0xff, 0xd9, 0x08, 0x00, 0x00,
}

func (m *Description) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Description) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Description) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Details) > 0 {
		i -= len(m.Details)
		copy(dAtA[i:], m.Details)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Details)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.SecurityContact) > 0 {
		i -= len(m.SecurityContact)
		copy(dAtA[i:], m.SecurityContact)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SecurityContact)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Website) > 0 {
		i -= len(m.Website)
		copy(dAtA[i:], m.Website)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Website)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Identity) > 0 {
		i -= len(m.Identity)
		copy(dAtA[i:], m.Identity)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Identity)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Moniker) > 0 {
		i -= len(m.Moniker)
		copy(dAtA[i:], m.Moniker)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Moniker)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StorageProvider) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageProvider) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageProvider) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BlsKey) > 0 {
		i -= len(m.BlsKey)
		copy(dAtA[i:], m.BlsKey)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BlsKey)))
		i--
		dAtA[i] = 0x62
	}
	{
		size, err := m.Description.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	if len(m.Endpoint) > 0 {
		i -= len(m.Endpoint)
		copy(dAtA[i:], m.Endpoint)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Endpoint)))
		i--
		dAtA[i] = 0x52
	}
	if m.Status != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x48
	}
	{
		size := m.TotalDeposit.Size()
		i -= size
		if _, err := m.TotalDeposit.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	if len(m.MaintenanceAddress) > 0 {
		i -= len(m.MaintenanceAddress)
		copy(dAtA[i:], m.MaintenanceAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.MaintenanceAddress)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.GcAddress) > 0 {
		i -= len(m.GcAddress)
		copy(dAtA[i:], m.GcAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.GcAddress)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ApprovalAddress) > 0 {
		i -= len(m.ApprovalAddress)
		copy(dAtA[i:], m.ApprovalAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ApprovalAddress)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.SealAddress) > 0 {
		i -= len(m.SealAddress)
		copy(dAtA[i:], m.SealAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SealAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.FundingAddress) > 0 {
		i -= len(m.FundingAddress)
		copy(dAtA[i:], m.FundingAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.FundingAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.OperatorAddress) > 0 {
		i -= len(m.OperatorAddress)
		copy(dAtA[i:], m.OperatorAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OperatorAddress)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RewardInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RewardInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RewardInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Amount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpStoragePrice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpStoragePrice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpStoragePrice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.StorePrice.Size()
		i -= size
		if _, err := m.StorePrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.FreeReadQuota != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.FreeReadQuota))
		i--
		dAtA[i] = 0x20
	}
	{
		size := m.ReadPrice.Size()
		i -= size
		if _, err := m.ReadPrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.UpdateTimeSec != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.UpdateTimeSec))
		i--
		dAtA[i] = 0x10
	}
	if m.SpId != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SpId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpStorePrice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpStorePrice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpStorePrice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.SecondaryStorePrice.Size()
		i -= size
		if _, err := m.SecondaryStorePrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.PrimaryStorePrice.Size()
		i -= size
		if _, err := m.PrimaryStorePrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.ReadPrice.Size()
		i -= size
		if _, err := m.ReadPrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.UpdateTimeSec != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.UpdateTimeSec))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SpMaintenanceStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpMaintenanceStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpMaintenanceStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Records) > 0 {
		for iNdEx := len(m.Records) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Records[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MaintenanceRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MaintenanceRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MaintenanceRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RequestAt != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.RequestAt))
		i--
		dAtA[i] = 0x20
	}
	if m.ActualDuration != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ActualDuration))
		i--
		dAtA[i] = 0x18
	}
	if m.RequestDuration != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.RequestDuration))
		i--
		dAtA[i] = 0x10
	}
	if m.Height != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Description) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Moniker)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Identity)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Website)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SecurityContact)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Details)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *StorageProvider) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovTypes(uint64(m.Id))
	}
	l = len(m.OperatorAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.FundingAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SealAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ApprovalAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.GcAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.MaintenanceAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.TotalDeposit.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.Status != 0 {
		n += 1 + sovTypes(uint64(m.Status))
	}
	l = len(m.Endpoint)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Description.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = len(m.BlsKey)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *RewardInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovTypes(uint64(l))
	return n
}

func (m *SpStoragePrice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SpId != 0 {
		n += 1 + sovTypes(uint64(m.SpId))
	}
	if m.UpdateTimeSec != 0 {
		n += 1 + sovTypes(uint64(m.UpdateTimeSec))
	}
	l = m.ReadPrice.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.FreeReadQuota != 0 {
		n += 1 + sovTypes(uint64(m.FreeReadQuota))
	}
	l = m.StorePrice.Size()
	n += 1 + l + sovTypes(uint64(l))
	return n
}

func (m *GlobalSpStorePrice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UpdateTimeSec != 0 {
		n += 1 + sovTypes(uint64(m.UpdateTimeSec))
	}
	l = m.ReadPrice.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.PrimaryStorePrice.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.SecondaryStorePrice.Size()
	n += 1 + l + sovTypes(uint64(l))
	return n
}

func (m *SpMaintenanceStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Records) > 0 {
		for _, e := range m.Records {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *MaintenanceRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Height != 0 {
		n += 1 + sovTypes(uint64(m.Height))
	}
	if m.RequestDuration != 0 {
		n += 1 + sovTypes(uint64(m.RequestDuration))
	}
	if m.ActualDuration != 0 {
		n += 1 + sovTypes(uint64(m.ActualDuration))
	}
	if m.RequestAt != 0 {
		n += 1 + sovTypes(uint64(m.RequestAt))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Description) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Description: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Description: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Moniker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Moniker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Identity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Website", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Website = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityContact", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecurityContact = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Details", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Details = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageProvider) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageProvider: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageProvider: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FundingAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FundingAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SealAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SealAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApprovalAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GcAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GcAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaintenanceAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaintenanceAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalDeposit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalDeposit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Endpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Description.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlsKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlsKey = append(m.BlsKey[:0], dAtA[iNdEx:postIndex]...)
			if m.BlsKey == nil {
				m.BlsKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RewardInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RewardInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RewardInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpStoragePrice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpStoragePrice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpStoragePrice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpId", wireType)
			}
			m.SpId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateTimeSec", wireType)
			}
			m.UpdateTimeSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateTimeSec |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReadPrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FreeReadQuota", wireType)
			}
			m.FreeReadQuota = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FreeReadQuota |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorePrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StorePrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpStorePrice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpStorePrice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpStorePrice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateTimeSec", wireType)
			}
			m.UpdateTimeSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateTimeSec |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReadPrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryStorePrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PrimaryStorePrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecondaryStorePrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SecondaryStorePrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpMaintenanceStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpMaintenanceStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpMaintenanceStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Records", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Records = append(m.Records, &MaintenanceRecord{})
			if err := m.Records[len(m.Records)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MaintenanceRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MaintenanceRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MaintenanceRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestDuration", wireType)
			}
			m.RequestDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestDuration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActualDuration", wireType)
			}
			m.ActualDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActualDuration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestAt", wireType)
			}
			m.RequestAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
