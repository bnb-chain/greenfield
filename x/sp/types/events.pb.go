// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: greenfield/sp/events.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// EventCreateStorageProvider is emitted when there is a storage provider created
type EventCreateStorageProvider struct {
	// sp_id defines the identifier of storage provider which generated on-chain
	SpId uint32 `protobuf:"varint,1,opt,name=sp_id,json=spId,proto3" json:"sp_id,omitempty"`
	// sp_address is the operator address of the storage provider
	SpAddress string `protobuf:"bytes,2,opt,name=sp_address,json=spAddress,proto3" json:"sp_address,omitempty"`
	// funding_address is the funding account address of the storage provider
	FundingAddress string `protobuf:"bytes,3,opt,name=funding_address,json=fundingAddress,proto3" json:"funding_address,omitempty"`
	// seal_address is the account address for SealObject Tx
	SealAddress string `protobuf:"bytes,4,opt,name=seal_address,json=sealAddress,proto3" json:"seal_address,omitempty"`
	// approval_address is the account address for approve create bucket/object signature
	ApprovalAddress string `protobuf:"bytes,5,opt,name=approval_address,json=approvalAddress,proto3" json:"approval_address,omitempty"`
	// gc_address defines one of the storage provider's accounts which is used for gc purpose
	GcAddress string `protobuf:"bytes,6,opt,name=gc_address,json=gcAddress,proto3" json:"gc_address,omitempty"`
	// maintenance_address defines one of the storage provider's accounts which is used for testing while in maintenance mode
	MaintenanceAddress string `protobuf:"bytes,7,opt,name=maintenance_address,json=maintenanceAddress,proto3" json:"maintenance_address,omitempty"`
	// endpoint is the domain name address used by SP to provide storage services
	Endpoint string `protobuf:"bytes,8,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	// total_deposit is the token coin that the storage provider deposit to the storage module
	TotalDeposit *types.Coin `protobuf:"bytes,9,opt,name=total_deposit,json=totalDeposit,proto3" json:"total_deposit,omitempty"`
	// status defines the status of the storage provider
	Status Status `protobuf:"varint,10,opt,name=status,proto3,enum=greenfield.sp.Status" json:"status,omitempty"`
	// description defines the description terms for the storage provider
	Description Description `protobuf:"bytes,11,opt,name=description,proto3" json:"description"`
	// bls_key defines the bls pub key owned by storage provider used when sealing object and completing migration
	BlsKey string `protobuf:"bytes,12,opt,name=bls_key,json=blsKey,proto3" json:"bls_key,omitempty"`
}

func (m *EventCreateStorageProvider) Reset()         { *m = EventCreateStorageProvider{} }
func (m *EventCreateStorageProvider) String() string { return proto.CompactTextString(m) }
func (*EventCreateStorageProvider) ProtoMessage()    {}
func (*EventCreateStorageProvider) Descriptor() ([]byte, []int) {
	return fileDescriptor_685cbfa50fdf0841, []int{0}
}
func (m *EventCreateStorageProvider) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventCreateStorageProvider) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventCreateStorageProvider.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventCreateStorageProvider) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventCreateStorageProvider.Merge(m, src)
}
func (m *EventCreateStorageProvider) XXX_Size() int {
	return m.Size()
}
func (m *EventCreateStorageProvider) XXX_DiscardUnknown() {
	xxx_messageInfo_EventCreateStorageProvider.DiscardUnknown(m)
}

var xxx_messageInfo_EventCreateStorageProvider proto.InternalMessageInfo

func (m *EventCreateStorageProvider) GetSpId() uint32 {
	if m != nil {
		return m.SpId
	}
	return 0
}

func (m *EventCreateStorageProvider) GetSpAddress() string {
	if m != nil {
		return m.SpAddress
	}
	return ""
}

func (m *EventCreateStorageProvider) GetFundingAddress() string {
	if m != nil {
		return m.FundingAddress
	}
	return ""
}

func (m *EventCreateStorageProvider) GetSealAddress() string {
	if m != nil {
		return m.SealAddress
	}
	return ""
}

func (m *EventCreateStorageProvider) GetApprovalAddress() string {
	if m != nil {
		return m.ApprovalAddress
	}
	return ""
}

func (m *EventCreateStorageProvider) GetGcAddress() string {
	if m != nil {
		return m.GcAddress
	}
	return ""
}

func (m *EventCreateStorageProvider) GetMaintenanceAddress() string {
	if m != nil {
		return m.MaintenanceAddress
	}
	return ""
}

func (m *EventCreateStorageProvider) GetEndpoint() string {
	if m != nil {
		return m.Endpoint
	}
	return ""
}

func (m *EventCreateStorageProvider) GetTotalDeposit() *types.Coin {
	if m != nil {
		return m.TotalDeposit
	}
	return nil
}

func (m *EventCreateStorageProvider) GetStatus() Status {
	if m != nil {
		return m.Status
	}
	return STATUS_IN_SERVICE
}

func (m *EventCreateStorageProvider) GetDescription() Description {
	if m != nil {
		return m.Description
	}
	return Description{}
}

func (m *EventCreateStorageProvider) GetBlsKey() string {
	if m != nil {
		return m.BlsKey
	}
	return ""
}

// EventEditStorageProvider is emitted when SP's metadata is edited.
type EventEditStorageProvider struct {
	// sp_id defines the identifier of storage provider which generated on-chain
	SpId uint32 `protobuf:"varint,1,opt,name=sp_id,json=spId,proto3" json:"sp_id,omitempty"`
	// sp_address is the operator address of the storage provider
	SpAddress string `protobuf:"bytes,2,opt,name=sp_address,json=spAddress,proto3" json:"sp_address,omitempty"`
	// endpoint is the service endpoint of the storage provider
	Endpoint string `protobuf:"bytes,3,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	// description defines the description terms for the storage provider
	Description Description `protobuf:"bytes,4,opt,name=description,proto3" json:"description"`
	// seal_address is the account address for SealObject Tx
	SealAddress string `protobuf:"bytes,5,opt,name=seal_address,json=sealAddress,proto3" json:"seal_address,omitempty"`
	// approval_address is the account address for approve create bucket/object signature
	ApprovalAddress string `protobuf:"bytes,6,opt,name=approval_address,json=approvalAddress,proto3" json:"approval_address,omitempty"`
	// gc_address defines one of the storage provider's accounts which is used for gc purpose
	GcAddress string `protobuf:"bytes,7,opt,name=gc_address,json=gcAddress,proto3" json:"gc_address,omitempty"`
	// maintenance_address defines one of the storage provider's accounts which is used for testing while in maintenance mode
	MaintenanceAddress string `protobuf:"bytes,8,opt,name=maintenance_address,json=maintenanceAddress,proto3" json:"maintenance_address,omitempty"`
	// bls_key defines the bls pub key owned by storage provider used when sealing object
	BlsKey string `protobuf:"bytes,9,opt,name=bls_key,json=blsKey,proto3" json:"bls_key,omitempty"`
}

func (m *EventEditStorageProvider) Reset()         { *m = EventEditStorageProvider{} }
func (m *EventEditStorageProvider) String() string { return proto.CompactTextString(m) }
func (*EventEditStorageProvider) ProtoMessage()    {}
func (*EventEditStorageProvider) Descriptor() ([]byte, []int) {
	return fileDescriptor_685cbfa50fdf0841, []int{1}
}
func (m *EventEditStorageProvider) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventEditStorageProvider) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventEditStorageProvider.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventEditStorageProvider) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventEditStorageProvider.Merge(m, src)
}
func (m *EventEditStorageProvider) XXX_Size() int {
	return m.Size()
}
func (m *EventEditStorageProvider) XXX_DiscardUnknown() {
	xxx_messageInfo_EventEditStorageProvider.DiscardUnknown(m)
}

var xxx_messageInfo_EventEditStorageProvider proto.InternalMessageInfo

func (m *EventEditStorageProvider) GetSpId() uint32 {
	if m != nil {
		return m.SpId
	}
	return 0
}

func (m *EventEditStorageProvider) GetSpAddress() string {
	if m != nil {
		return m.SpAddress
	}
	return ""
}

func (m *EventEditStorageProvider) GetEndpoint() string {
	if m != nil {
		return m.Endpoint
	}
	return ""
}

func (m *EventEditStorageProvider) GetDescription() Description {
	if m != nil {
		return m.Description
	}
	return Description{}
}

func (m *EventEditStorageProvider) GetSealAddress() string {
	if m != nil {
		return m.SealAddress
	}
	return ""
}

func (m *EventEditStorageProvider) GetApprovalAddress() string {
	if m != nil {
		return m.ApprovalAddress
	}
	return ""
}

func (m *EventEditStorageProvider) GetGcAddress() string {
	if m != nil {
		return m.GcAddress
	}
	return ""
}

func (m *EventEditStorageProvider) GetMaintenanceAddress() string {
	if m != nil {
		return m.MaintenanceAddress
	}
	return ""
}

func (m *EventEditStorageProvider) GetBlsKey() string {
	if m != nil {
		return m.BlsKey
	}
	return ""
}

// EventDeposit is emitted when sp deposit tokens.
type EventDeposit struct {
	// funding_address is the funding account address of the storage provider
	FundingAddress string `protobuf:"bytes,1,opt,name=funding_address,json=fundingAddress,proto3" json:"funding_address,omitempty"`
	// deposit is the token coin deposited this message
	Deposit string `protobuf:"bytes,2,opt,name=deposit,proto3" json:"deposit,omitempty"`
	// total_deposit is the total token coins this storage provider deposited
	TotalDeposit string `protobuf:"bytes,3,opt,name=total_deposit,json=totalDeposit,proto3" json:"total_deposit,omitempty"`
}

func (m *EventDeposit) Reset()         { *m = EventDeposit{} }
func (m *EventDeposit) String() string { return proto.CompactTextString(m) }
func (*EventDeposit) ProtoMessage()    {}
func (*EventDeposit) Descriptor() ([]byte, []int) {
	return fileDescriptor_685cbfa50fdf0841, []int{2}
}
func (m *EventDeposit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventDeposit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventDeposit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventDeposit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventDeposit.Merge(m, src)
}
func (m *EventDeposit) XXX_Size() int {
	return m.Size()
}
func (m *EventDeposit) XXX_DiscardUnknown() {
	xxx_messageInfo_EventDeposit.DiscardUnknown(m)
}

var xxx_messageInfo_EventDeposit proto.InternalMessageInfo

func (m *EventDeposit) GetFundingAddress() string {
	if m != nil {
		return m.FundingAddress
	}
	return ""
}

func (m *EventDeposit) GetDeposit() string {
	if m != nil {
		return m.Deposit
	}
	return ""
}

func (m *EventDeposit) GetTotalDeposit() string {
	if m != nil {
		return m.TotalDeposit
	}
	return ""
}

type EventSpStoragePriceUpdate struct {
	// sp id
	SpId uint32 `protobuf:"varint,1,opt,name=sp_id,json=spId,proto3" json:"sp_id,omitempty"`
	// update time, in unix timestamp
	UpdateTimeSec int64 `protobuf:"varint,2,opt,name=update_time_sec,json=updateTimeSec,proto3" json:"update_time_sec,omitempty"`
	// read price, in bnb wei per charge byte
	ReadPrice github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,3,opt,name=read_price,json=readPrice,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"read_price"`
	// free read quota, in byte
	FreeReadQuota uint64 `protobuf:"varint,4,opt,name=free_read_quota,json=freeReadQuota,proto3" json:"free_read_quota,omitempty"`
	// store price, in bnb wei per charge byte
	StorePrice github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,5,opt,name=store_price,json=storePrice,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"store_price"`
}

func (m *EventSpStoragePriceUpdate) Reset()         { *m = EventSpStoragePriceUpdate{} }
func (m *EventSpStoragePriceUpdate) String() string { return proto.CompactTextString(m) }
func (*EventSpStoragePriceUpdate) ProtoMessage()    {}
func (*EventSpStoragePriceUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_685cbfa50fdf0841, []int{3}
}
func (m *EventSpStoragePriceUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSpStoragePriceUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSpStoragePriceUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSpStoragePriceUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSpStoragePriceUpdate.Merge(m, src)
}
func (m *EventSpStoragePriceUpdate) XXX_Size() int {
	return m.Size()
}
func (m *EventSpStoragePriceUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSpStoragePriceUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_EventSpStoragePriceUpdate proto.InternalMessageInfo

func (m *EventSpStoragePriceUpdate) GetSpId() uint32 {
	if m != nil {
		return m.SpId
	}
	return 0
}

func (m *EventSpStoragePriceUpdate) GetUpdateTimeSec() int64 {
	if m != nil {
		return m.UpdateTimeSec
	}
	return 0
}

func (m *EventSpStoragePriceUpdate) GetFreeReadQuota() uint64 {
	if m != nil {
		return m.FreeReadQuota
	}
	return 0
}

type EventGlobalSpStorePriceUpdate struct {
	// update time, in unix timestamp
	UpdateTimeSec int64 `protobuf:"varint,1,opt,name=update_time_sec,json=updateTimeSec,proto3" json:"update_time_sec,omitempty"`
	// read price, in bnb wei per charge byte
	ReadPrice github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,2,opt,name=read_price,json=readPrice,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"read_price"`
	// primary store price, in bnb wei per charge byte
	PrimaryStorePrice github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,3,opt,name=primary_store_price,json=primaryStorePrice,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"primary_store_price"`
	// secondary store price, in bnb wei per charge byte
	SecondaryStorePrice github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,4,opt,name=secondary_store_price,json=secondaryStorePrice,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"secondary_store_price"`
}

func (m *EventGlobalSpStorePriceUpdate) Reset()         { *m = EventGlobalSpStorePriceUpdate{} }
func (m *EventGlobalSpStorePriceUpdate) String() string { return proto.CompactTextString(m) }
func (*EventGlobalSpStorePriceUpdate) ProtoMessage()    {}
func (*EventGlobalSpStorePriceUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_685cbfa50fdf0841, []int{4}
}
func (m *EventGlobalSpStorePriceUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventGlobalSpStorePriceUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventGlobalSpStorePriceUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventGlobalSpStorePriceUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventGlobalSpStorePriceUpdate.Merge(m, src)
}
func (m *EventGlobalSpStorePriceUpdate) XXX_Size() int {
	return m.Size()
}
func (m *EventGlobalSpStorePriceUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_EventGlobalSpStorePriceUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_EventGlobalSpStorePriceUpdate proto.InternalMessageInfo

func (m *EventGlobalSpStorePriceUpdate) GetUpdateTimeSec() int64 {
	if m != nil {
		return m.UpdateTimeSec
	}
	return 0
}

// EventUpdateStorageProviderStatus is emitted when the SP update its status successfully
type EventUpdateStorageProviderStatus struct {
	// sp_id defines the identifier of storage provider which generated on-chain
	SpId uint32 `protobuf:"varint,1,opt,name=sp_id,json=spId,proto3" json:"sp_id,omitempty"`
	// sp_address is the operator address of the storage provider
	SpAddress string `protobuf:"bytes,2,opt,name=sp_address,json=spAddress,proto3" json:"sp_address,omitempty"`
	// pre status
	PreStatus string `protobuf:"bytes,3,opt,name=pre_status,json=preStatus,proto3" json:"pre_status,omitempty"`
	// new status
	NewStatus string `protobuf:"bytes,4,opt,name=new_status,json=newStatus,proto3" json:"new_status,omitempty"`
}

func (m *EventUpdateStorageProviderStatus) Reset()         { *m = EventUpdateStorageProviderStatus{} }
func (m *EventUpdateStorageProviderStatus) String() string { return proto.CompactTextString(m) }
func (*EventUpdateStorageProviderStatus) ProtoMessage()    {}
func (*EventUpdateStorageProviderStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_685cbfa50fdf0841, []int{5}
}
func (m *EventUpdateStorageProviderStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventUpdateStorageProviderStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventUpdateStorageProviderStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventUpdateStorageProviderStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventUpdateStorageProviderStatus.Merge(m, src)
}
func (m *EventUpdateStorageProviderStatus) XXX_Size() int {
	return m.Size()
}
func (m *EventUpdateStorageProviderStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_EventUpdateStorageProviderStatus.DiscardUnknown(m)
}

var xxx_messageInfo_EventUpdateStorageProviderStatus proto.InternalMessageInfo

func (m *EventUpdateStorageProviderStatus) GetSpId() uint32 {
	if m != nil {
		return m.SpId
	}
	return 0
}

func (m *EventUpdateStorageProviderStatus) GetSpAddress() string {
	if m != nil {
		return m.SpAddress
	}
	return ""
}

func (m *EventUpdateStorageProviderStatus) GetPreStatus() string {
	if m != nil {
		return m.PreStatus
	}
	return ""
}

func (m *EventUpdateStorageProviderStatus) GetNewStatus() string {
	if m != nil {
		return m.NewStatus
	}
	return ""
}

func init() {
	proto.RegisterType((*EventCreateStorageProvider)(nil), "greenfield.sp.EventCreateStorageProvider")
	proto.RegisterType((*EventEditStorageProvider)(nil), "greenfield.sp.EventEditStorageProvider")
	proto.RegisterType((*EventDeposit)(nil), "greenfield.sp.EventDeposit")
	proto.RegisterType((*EventSpStoragePriceUpdate)(nil), "greenfield.sp.EventSpStoragePriceUpdate")
	proto.RegisterType((*EventGlobalSpStorePriceUpdate)(nil), "greenfield.sp.EventGlobalSpStorePriceUpdate")
	proto.RegisterType((*EventUpdateStorageProviderStatus)(nil), "greenfield.sp.EventUpdateStorageProviderStatus")
}

func init() { proto.RegisterFile("greenfield/sp/events.proto", fileDescriptor_685cbfa50fdf0841) }

var fileDescriptor_685cbfa50fdf0841 = []byte{
	// 819 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x56, 0xcd, 0x6e, 0x1b, 0x37,
	0x10, 0xf6, 0x5a, 0x3f, 0xb6, 0x46, 0x56, 0xdc, 0xae, 0x13, 0x74, 0x2d, 0xc0, 0x8a, 0xa0, 0x02,
	0x81, 0x51, 0x40, 0x12, 0x92, 0x1e, 0x72, 0x68, 0x51, 0x20, 0xb6, 0x82, 0x22, 0xe8, 0xa5, 0x5d,
	0xb5, 0x97, 0x16, 0xc5, 0x82, 0xbb, 0x1c, 0x6f, 0x88, 0x48, 0x24, 0x4b, 0x52, 0x4e, 0x7d, 0xef,
	0x03, 0xe4, 0xde, 0x77, 0xe8, 0x29, 0xc7, 0x3e, 0x40, 0x8e, 0x41, 0x4e, 0x45, 0x0f, 0x41, 0x61,
	0x1f, 0xfa, 0x1a, 0xc5, 0x72, 0xb9, 0xd2, 0x4a, 0x30, 0x20, 0xd4, 0x56, 0x4e, 0x36, 0x39, 0xfc,
	0xbe, 0x19, 0x7e, 0xf3, 0x71, 0xb4, 0xd0, 0x4e, 0x15, 0x22, 0x3f, 0x63, 0x38, 0xa1, 0x43, 0x2d,
	0x87, 0x78, 0x8e, 0xdc, 0xe8, 0x81, 0x54, 0xc2, 0x08, 0xbf, 0xb5, 0x88, 0x0d, 0xb4, 0x6c, 0x77,
	0x12, 0xa1, 0xa7, 0x42, 0x0f, 0x63, 0xa2, 0x71, 0x78, 0xfe, 0x30, 0x46, 0x43, 0x1e, 0x0e, 0x13,
	0xc1, 0x78, 0x7e, 0xbc, 0x7d, 0x98, 0xc7, 0x23, 0xbb, 0x1a, 0xe6, 0x0b, 0x17, 0xba, 0x9b, 0x8a,
	0x54, 0xe4, 0xfb, 0xd9, 0x7f, 0x05, 0x60, 0x39, 0xb7, 0xb9, 0x90, 0xe8, 0x00, 0xbd, 0xdf, 0x6b,
	0xd0, 0x7e, 0x9a, 0xd5, 0x72, 0xaa, 0x90, 0x18, 0x1c, 0x1b, 0xa1, 0x48, 0x8a, 0xdf, 0x2a, 0x71,
	0xce, 0x28, 0x2a, 0xff, 0x00, 0x6a, 0x5a, 0x46, 0x8c, 0x06, 0x5e, 0xd7, 0x3b, 0x6e, 0x85, 0x55,
	0x2d, 0x9f, 0x51, 0xff, 0x31, 0x80, 0x96, 0x11, 0xa1, 0x54, 0xa1, 0xd6, 0xc1, 0x76, 0xd7, 0x3b,
	0x6e, 0x9c, 0x04, 0xef, 0x5e, 0xf7, 0xef, 0xba, 0x52, 0x9e, 0xe4, 0x91, 0xb1, 0x51, 0x8c, 0xa7,
	0x61, 0x43, 0x4b, 0xb7, 0xe1, 0x3f, 0x81, 0xfd, 0xb3, 0x19, 0xa7, 0x8c, 0xa7, 0x73, 0x74, 0x65,
	0x0d, 0xfa, 0x8e, 0x03, 0x14, 0x14, 0x5f, 0xc0, 0x9e, 0x46, 0x32, 0x99, 0xe3, 0xab, 0x6b, 0xf0,
	0xcd, 0xec, 0x74, 0x01, 0x3e, 0x85, 0x8f, 0x88, 0x94, 0x4a, 0x9c, 0x97, 0x08, 0x6a, 0x6b, 0x08,
	0xf6, 0x0b, 0x44, 0x41, 0xf2, 0x18, 0x20, 0x4d, 0xe6, 0xf0, 0xfa, 0xba, 0xdb, 0xa7, 0x49, 0x01,
	0x7c, 0x06, 0x07, 0x53, 0xc2, 0xb8, 0x41, 0x4e, 0x78, 0x82, 0x73, 0x86, 0x9d, 0x35, 0x0c, 0x7e,
	0x09, 0x54, 0x50, 0xb5, 0x61, 0x17, 0x39, 0x95, 0x82, 0x71, 0x13, 0xec, 0x66, 0xf8, 0x70, 0xbe,
	0xf6, 0xbf, 0x82, 0x96, 0x11, 0x86, 0x4c, 0x22, 0x8a, 0x52, 0x68, 0x66, 0x82, 0x46, 0xd7, 0x3b,
	0x6e, 0x3e, 0x3a, 0x1c, 0x38, 0xf6, 0xcc, 0x55, 0x03, 0xe7, 0xaa, 0xc1, 0xa9, 0x60, 0x3c, 0xdc,
	0xb3, 0xe7, 0x47, 0xf9, 0x71, 0xbf, 0x0f, 0x75, 0x6d, 0x88, 0x99, 0xe9, 0x00, 0xba, 0xde, 0xf1,
	0x9d, 0x47, 0xf7, 0x06, 0x4b, 0xee, 0x1c, 0x8c, 0x6d, 0x30, 0x74, 0x87, 0xfc, 0x13, 0x68, 0x52,
	0xd4, 0x89, 0x62, 0xd2, 0x30, 0xc1, 0x83, 0xa6, 0x4d, 0xd6, 0x5e, 0xc1, 0x8c, 0x16, 0x27, 0x4e,
	0xaa, 0x6f, 0xde, 0xdf, 0xdf, 0x0a, 0xcb, 0x20, 0xff, 0x13, 0xd8, 0x89, 0x27, 0x3a, 0x7a, 0x81,
	0x17, 0xc1, 0x9e, 0xbd, 0x4d, 0x3d, 0x9e, 0xe8, 0x6f, 0xf0, 0xa2, 0xf7, 0x6f, 0x05, 0x02, 0xeb,
	0xce, 0xa7, 0x94, 0x99, 0x0f, 0xeb, 0xcd, 0xb2, 0xa4, 0x95, 0x15, 0x49, 0x57, 0xee, 0x58, 0xbd,
	0xc9, 0x1d, 0x57, 0x8d, 0x5b, 0xbb, 0xad, 0x71, 0xeb, 0xb7, 0x33, 0xee, 0xce, 0xad, 0x8d, 0xbb,
	0x7b, 0x03, 0xe3, 0x96, 0x3a, 0xdd, 0x58, 0xea, 0xf4, 0x2b, 0x0f, 0xf6, 0x6c, 0xa7, 0x0b, 0x1b,
	0x5e, 0x33, 0x2b, 0xbc, 0xff, 0x39, 0x2b, 0x02, 0xd8, 0x29, 0xde, 0x80, 0x35, 0x42, 0x58, 0x2c,
	0xfd, 0x4f, 0x57, 0xdf, 0x48, 0xde, 0xf1, 0xa5, 0x87, 0xd0, 0xfb, 0x73, 0x1b, 0x0e, 0x6d, 0x49,
	0x63, 0x39, 0xb7, 0x1e, 0x4b, 0xf0, 0x07, 0x49, 0x89, 0xc1, 0xeb, 0xdd, 0xf7, 0x00, 0xf6, 0x67,
	0x36, 0x1c, 0x19, 0x36, 0xc5, 0x48, 0x63, 0x62, 0x33, 0x57, 0xc2, 0x56, 0xbe, 0xfd, 0x3d, 0x9b,
	0xe2, 0x18, 0x13, 0xff, 0x27, 0x00, 0x85, 0x84, 0x46, 0x32, 0x23, 0x74, 0x33, 0xf0, 0xcb, 0xcc,
	0x33, 0x7f, 0xbf, 0xbf, 0xff, 0x20, 0x65, 0xe6, 0xf9, 0x2c, 0x1e, 0x24, 0x62, 0xea, 0x66, 0xbb,
	0xfb, 0xd3, 0xd7, 0xf4, 0x85, 0x9b, 0xdd, 0x23, 0x4c, 0xde, 0xbd, 0xee, 0x83, 0x53, 0x61, 0x84,
	0x49, 0xd8, 0xc8, 0xf8, 0x6c, 0x7d, 0x59, 0x11, 0x67, 0x0a, 0x31, 0xb2, 0x19, 0x7e, 0x99, 0x09,
	0x43, 0xac, 0x63, 0xab, 0x61, 0x2b, 0xdb, 0x0e, 0x91, 0xd0, 0xef, 0xb2, 0x4d, 0xff, 0x67, 0x68,
	0x6a, 0x23, 0x14, 0xba, 0x2a, 0x6a, 0x1b, 0xa8, 0x02, 0x2c, 0xa1, 0x2d, 0xa3, 0xf7, 0x5b, 0x05,
	0x8e, 0xac, 0x7c, 0x5f, 0x4f, 0x44, 0x4c, 0x26, 0xb9, 0x88, 0x4b, 0x12, 0x5e, 0xa3, 0x96, 0xb7,
	0x5e, 0xad, 0xed, 0xcd, 0xaa, 0x35, 0x81, 0x03, 0xa9, 0xd8, 0x94, 0xa8, 0x8b, 0xa8, 0xac, 0xc6,
	0x26, 0x7a, 0xf2, 0xb1, 0x23, 0x5e, 0x5c, 0xdc, 0x97, 0x70, 0x4f, 0x63, 0x22, 0x38, 0x5d, 0xcd,
	0x57, 0xdd, 0x40, 0xbe, 0x83, 0x39, 0xf5, 0x22, 0x63, 0xef, 0x0f, 0x0f, 0xba, 0xb6, 0x0d, 0xb9,
	0xe8, 0x2b, 0x43, 0x34, 0x1f, 0xe6, 0x1b, 0x1e, 0xa5, 0x47, 0x00, 0x52, 0x61, 0xe4, 0x7e, 0x45,
	0xf2, 0xa7, 0xd5, 0x90, 0x0a, 0x5d, 0xb2, 0x23, 0x00, 0x8e, 0x2f, 0x8b, 0x70, 0x35, 0x0f, 0x73,
	0x7c, 0x99, 0x87, 0x4f, 0x46, 0x6f, 0x2e, 0x3b, 0xde, 0xdb, 0xcb, 0x8e, 0xf7, 0xcf, 0x65, 0xc7,
	0x7b, 0x75, 0xd5, 0xd9, 0x7a, 0x7b, 0xd5, 0xd9, 0xfa, 0xeb, 0xaa, 0xb3, 0xf5, 0xe3, 0x67, 0x25,
	0x55, 0x62, 0x1e, 0xf7, 0x93, 0xe7, 0x84, 0xf1, 0x61, 0xe9, 0xdb, 0xe6, 0xd7, 0xf9, 0xd7, 0x4d,
	0x5c, 0xb7, 0x9f, 0x37, 0x9f, 0xff, 0x17, 0x00, 0x00, 0xff, 0xff, 0xdb, 0x8d, 0xb2, 0x3d, 0x77,
	0x09, 0x00, 0x00,
}

func (m *EventCreateStorageProvider) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventCreateStorageProvider) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventCreateStorageProvider) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BlsKey) > 0 {
		i -= len(m.BlsKey)
		copy(dAtA[i:], m.BlsKey)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.BlsKey)))
		i--
		dAtA[i] = 0x62
	}
	{
		size, err := m.Description.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	if m.Status != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x50
	}
	if m.TotalDeposit != nil {
		{
			size, err := m.TotalDeposit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Endpoint) > 0 {
		i -= len(m.Endpoint)
		copy(dAtA[i:], m.Endpoint)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Endpoint)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.MaintenanceAddress) > 0 {
		i -= len(m.MaintenanceAddress)
		copy(dAtA[i:], m.MaintenanceAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.MaintenanceAddress)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.GcAddress) > 0 {
		i -= len(m.GcAddress)
		copy(dAtA[i:], m.GcAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.GcAddress)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ApprovalAddress) > 0 {
		i -= len(m.ApprovalAddress)
		copy(dAtA[i:], m.ApprovalAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.ApprovalAddress)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.SealAddress) > 0 {
		i -= len(m.SealAddress)
		copy(dAtA[i:], m.SealAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.SealAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.FundingAddress) > 0 {
		i -= len(m.FundingAddress)
		copy(dAtA[i:], m.FundingAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.FundingAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SpAddress) > 0 {
		i -= len(m.SpAddress)
		copy(dAtA[i:], m.SpAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.SpAddress)))
		i--
		dAtA[i] = 0x12
	}
	if m.SpId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.SpId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventEditStorageProvider) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventEditStorageProvider) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventEditStorageProvider) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BlsKey) > 0 {
		i -= len(m.BlsKey)
		copy(dAtA[i:], m.BlsKey)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.BlsKey)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.MaintenanceAddress) > 0 {
		i -= len(m.MaintenanceAddress)
		copy(dAtA[i:], m.MaintenanceAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.MaintenanceAddress)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.GcAddress) > 0 {
		i -= len(m.GcAddress)
		copy(dAtA[i:], m.GcAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.GcAddress)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.ApprovalAddress) > 0 {
		i -= len(m.ApprovalAddress)
		copy(dAtA[i:], m.ApprovalAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.ApprovalAddress)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.SealAddress) > 0 {
		i -= len(m.SealAddress)
		copy(dAtA[i:], m.SealAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.SealAddress)))
		i--
		dAtA[i] = 0x2a
	}
	{
		size, err := m.Description.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Endpoint) > 0 {
		i -= len(m.Endpoint)
		copy(dAtA[i:], m.Endpoint)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Endpoint)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SpAddress) > 0 {
		i -= len(m.SpAddress)
		copy(dAtA[i:], m.SpAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.SpAddress)))
		i--
		dAtA[i] = 0x12
	}
	if m.SpId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.SpId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventDeposit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventDeposit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventDeposit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TotalDeposit) > 0 {
		i -= len(m.TotalDeposit)
		copy(dAtA[i:], m.TotalDeposit)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.TotalDeposit)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Deposit) > 0 {
		i -= len(m.Deposit)
		copy(dAtA[i:], m.Deposit)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Deposit)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FundingAddress) > 0 {
		i -= len(m.FundingAddress)
		copy(dAtA[i:], m.FundingAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.FundingAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSpStoragePriceUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSpStoragePriceUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSpStoragePriceUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.StorePrice.Size()
		i -= size
		if _, err := m.StorePrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.FreeReadQuota != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.FreeReadQuota))
		i--
		dAtA[i] = 0x20
	}
	{
		size := m.ReadPrice.Size()
		i -= size
		if _, err := m.ReadPrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.UpdateTimeSec != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.UpdateTimeSec))
		i--
		dAtA[i] = 0x10
	}
	if m.SpId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.SpId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventGlobalSpStorePriceUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventGlobalSpStorePriceUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventGlobalSpStorePriceUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.SecondaryStorePrice.Size()
		i -= size
		if _, err := m.SecondaryStorePrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.PrimaryStorePrice.Size()
		i -= size
		if _, err := m.PrimaryStorePrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.ReadPrice.Size()
		i -= size
		if _, err := m.ReadPrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.UpdateTimeSec != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.UpdateTimeSec))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventUpdateStorageProviderStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventUpdateStorageProviderStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventUpdateStorageProviderStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NewStatus) > 0 {
		i -= len(m.NewStatus)
		copy(dAtA[i:], m.NewStatus)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.NewStatus)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.PreStatus) > 0 {
		i -= len(m.PreStatus)
		copy(dAtA[i:], m.PreStatus)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.PreStatus)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SpAddress) > 0 {
		i -= len(m.SpAddress)
		copy(dAtA[i:], m.SpAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.SpAddress)))
		i--
		dAtA[i] = 0x12
	}
	if m.SpId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.SpId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintEvents(dAtA []byte, offset int, v uint64) int {
	offset -= sovEvents(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *EventCreateStorageProvider) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SpId != 0 {
		n += 1 + sovEvents(uint64(m.SpId))
	}
	l = len(m.SpAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.FundingAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.SealAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.ApprovalAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.GcAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.MaintenanceAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Endpoint)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.TotalDeposit != nil {
		l = m.TotalDeposit.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovEvents(uint64(m.Status))
	}
	l = m.Description.Size()
	n += 1 + l + sovEvents(uint64(l))
	l = len(m.BlsKey)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventEditStorageProvider) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SpId != 0 {
		n += 1 + sovEvents(uint64(m.SpId))
	}
	l = len(m.SpAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Endpoint)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = m.Description.Size()
	n += 1 + l + sovEvents(uint64(l))
	l = len(m.SealAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.ApprovalAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.GcAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.MaintenanceAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.BlsKey)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventDeposit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FundingAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Deposit)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.TotalDeposit)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventSpStoragePriceUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SpId != 0 {
		n += 1 + sovEvents(uint64(m.SpId))
	}
	if m.UpdateTimeSec != 0 {
		n += 1 + sovEvents(uint64(m.UpdateTimeSec))
	}
	l = m.ReadPrice.Size()
	n += 1 + l + sovEvents(uint64(l))
	if m.FreeReadQuota != 0 {
		n += 1 + sovEvents(uint64(m.FreeReadQuota))
	}
	l = m.StorePrice.Size()
	n += 1 + l + sovEvents(uint64(l))
	return n
}

func (m *EventGlobalSpStorePriceUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UpdateTimeSec != 0 {
		n += 1 + sovEvents(uint64(m.UpdateTimeSec))
	}
	l = m.ReadPrice.Size()
	n += 1 + l + sovEvents(uint64(l))
	l = m.PrimaryStorePrice.Size()
	n += 1 + l + sovEvents(uint64(l))
	l = m.SecondaryStorePrice.Size()
	n += 1 + l + sovEvents(uint64(l))
	return n
}

func (m *EventUpdateStorageProviderStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SpId != 0 {
		n += 1 + sovEvents(uint64(m.SpId))
	}
	l = len(m.SpAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.PreStatus)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.NewStatus)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func sovEvents(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozEvents(x uint64) (n int) {
	return sovEvents(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EventCreateStorageProvider) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventCreateStorageProvider: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventCreateStorageProvider: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpId", wireType)
			}
			m.SpId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FundingAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FundingAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SealAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SealAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApprovalAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GcAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GcAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaintenanceAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaintenanceAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Endpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalDeposit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TotalDeposit == nil {
				m.TotalDeposit = &types.Coin{}
			}
			if err := m.TotalDeposit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Description.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlsKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlsKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventEditStorageProvider) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventEditStorageProvider: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventEditStorageProvider: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpId", wireType)
			}
			m.SpId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Endpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Description.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SealAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SealAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApprovalAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GcAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GcAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaintenanceAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaintenanceAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlsKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlsKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventDeposit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventDeposit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventDeposit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FundingAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FundingAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deposit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Deposit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalDeposit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalDeposit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSpStoragePriceUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSpStoragePriceUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSpStoragePriceUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpId", wireType)
			}
			m.SpId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateTimeSec", wireType)
			}
			m.UpdateTimeSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateTimeSec |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReadPrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FreeReadQuota", wireType)
			}
			m.FreeReadQuota = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FreeReadQuota |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorePrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StorePrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventGlobalSpStorePriceUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventGlobalSpStorePriceUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventGlobalSpStorePriceUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateTimeSec", wireType)
			}
			m.UpdateTimeSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateTimeSec |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReadPrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryStorePrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PrimaryStorePrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecondaryStorePrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SecondaryStorePrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventUpdateStorageProviderStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventUpdateStorageProviderStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventUpdateStorageProviderStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpId", wireType)
			}
			m.SpId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreStatus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewStatus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEvents(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthEvents
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupEvents
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthEvents
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthEvents        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEvents          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupEvents = fmt.Errorf("proto: unexpected end of group")
)
