// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: greenfield/sp/events.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// EventCreateStorageProvider is emitted when there is a storage provider created
type EventCreateStorageProvider struct {
	// sp_address is the operator address of the storage provider
	SpAddress string `protobuf:"bytes,1,opt,name=sp_address,json=spAddress,proto3" json:"sp_address,omitempty"`
	// funding_address is the funding account address of the storage provider
	FundingAddress string `protobuf:"bytes,2,opt,name=funding_address,json=fundingAddress,proto3" json:"funding_address,omitempty"`
	// seal_address is the account address for SealObject Tx
	SealAddress string `protobuf:"bytes,3,opt,name=seal_address,json=sealAddress,proto3" json:"seal_address,omitempty"`
	// approval_address is the account address for approve create bucket/object signature
	ApprovalAddress string `protobuf:"bytes,4,opt,name=approval_address,json=approvalAddress,proto3" json:"approval_address,omitempty"`
	// endpoint is the domain name address used by SP to provide storage services
	Endpoint string `protobuf:"bytes,5,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	// total_deposit is the token coin that the storage provider deposit to the storage module
	TotalDeposit *types.Coin `protobuf:"bytes,6,opt,name=total_deposit,json=totalDeposit,proto3" json:"total_deposit,omitempty"`
}

func (m *EventCreateStorageProvider) Reset()         { *m = EventCreateStorageProvider{} }
func (m *EventCreateStorageProvider) String() string { return proto.CompactTextString(m) }
func (*EventCreateStorageProvider) ProtoMessage()    {}
func (*EventCreateStorageProvider) Descriptor() ([]byte, []int) {
	return fileDescriptor_685cbfa50fdf0841, []int{0}
}
func (m *EventCreateStorageProvider) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventCreateStorageProvider) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventCreateStorageProvider.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventCreateStorageProvider) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventCreateStorageProvider.Merge(m, src)
}
func (m *EventCreateStorageProvider) XXX_Size() int {
	return m.Size()
}
func (m *EventCreateStorageProvider) XXX_DiscardUnknown() {
	xxx_messageInfo_EventCreateStorageProvider.DiscardUnknown(m)
}

var xxx_messageInfo_EventCreateStorageProvider proto.InternalMessageInfo

func (m *EventCreateStorageProvider) GetSpAddress() string {
	if m != nil {
		return m.SpAddress
	}
	return ""
}

func (m *EventCreateStorageProvider) GetFundingAddress() string {
	if m != nil {
		return m.FundingAddress
	}
	return ""
}

func (m *EventCreateStorageProvider) GetSealAddress() string {
	if m != nil {
		return m.SealAddress
	}
	return ""
}

func (m *EventCreateStorageProvider) GetApprovalAddress() string {
	if m != nil {
		return m.ApprovalAddress
	}
	return ""
}

func (m *EventCreateStorageProvider) GetEndpoint() string {
	if m != nil {
		return m.Endpoint
	}
	return ""
}

func (m *EventCreateStorageProvider) GetTotalDeposit() *types.Coin {
	if m != nil {
		return m.TotalDeposit
	}
	return nil
}

// EventEditStorageProvider is emitted when SP's metadata is edited.
type EventEditStorageProvider struct {
	// old_endpoint is the service endpoint of the storage provider before edit
	OldEndpoint string `protobuf:"bytes,1,opt,name=old_endpoint,json=oldEndpoint,proto3" json:"old_endpoint,omitempty"`
	// new_endpoint is the service endpoint of the storage provider after edit
	NewEndpoint string `protobuf:"bytes,2,opt,name=new_endpoint,json=newEndpoint,proto3" json:"new_endpoint,omitempty"`
}

func (m *EventEditStorageProvider) Reset()         { *m = EventEditStorageProvider{} }
func (m *EventEditStorageProvider) String() string { return proto.CompactTextString(m) }
func (*EventEditStorageProvider) ProtoMessage()    {}
func (*EventEditStorageProvider) Descriptor() ([]byte, []int) {
	return fileDescriptor_685cbfa50fdf0841, []int{1}
}
func (m *EventEditStorageProvider) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventEditStorageProvider) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventEditStorageProvider.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventEditStorageProvider) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventEditStorageProvider.Merge(m, src)
}
func (m *EventEditStorageProvider) XXX_Size() int {
	return m.Size()
}
func (m *EventEditStorageProvider) XXX_DiscardUnknown() {
	xxx_messageInfo_EventEditStorageProvider.DiscardUnknown(m)
}

var xxx_messageInfo_EventEditStorageProvider proto.InternalMessageInfo

func (m *EventEditStorageProvider) GetOldEndpoint() string {
	if m != nil {
		return m.OldEndpoint
	}
	return ""
}

func (m *EventEditStorageProvider) GetNewEndpoint() string {
	if m != nil {
		return m.NewEndpoint
	}
	return ""
}

// EventDeposit is emitted when sp deposit tokens.
type EventDeposit struct {
	// sp_address is the account address of storage provider
	SpAddress string `protobuf:"bytes,1,opt,name=sp_address,json=spAddress,proto3" json:"sp_address,omitempty"`
	// deposit is the token coin deposited this message
	Deposit string `protobuf:"bytes,2,opt,name=deposit,proto3" json:"deposit,omitempty"`
	// total_deposit is the total token coins this storage provider deposited
	TotalDeposit string `protobuf:"bytes,3,opt,name=total_deposit,json=totalDeposit,proto3" json:"total_deposit,omitempty"`
}

func (m *EventDeposit) Reset()         { *m = EventDeposit{} }
func (m *EventDeposit) String() string { return proto.CompactTextString(m) }
func (*EventDeposit) ProtoMessage()    {}
func (*EventDeposit) Descriptor() ([]byte, []int) {
	return fileDescriptor_685cbfa50fdf0841, []int{2}
}
func (m *EventDeposit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventDeposit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventDeposit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventDeposit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventDeposit.Merge(m, src)
}
func (m *EventDeposit) XXX_Size() int {
	return m.Size()
}
func (m *EventDeposit) XXX_DiscardUnknown() {
	xxx_messageInfo_EventDeposit.DiscardUnknown(m)
}

var xxx_messageInfo_EventDeposit proto.InternalMessageInfo

func (m *EventDeposit) GetSpAddress() string {
	if m != nil {
		return m.SpAddress
	}
	return ""
}

func (m *EventDeposit) GetDeposit() string {
	if m != nil {
		return m.Deposit
	}
	return ""
}

func (m *EventDeposit) GetTotalDeposit() string {
	if m != nil {
		return m.TotalDeposit
	}
	return ""
}

type EventSpStoragePriceUpdate struct {
	// sp address
	SpAddress string `protobuf:"bytes,1,opt,name=sp_address,json=spAddress,proto3" json:"sp_address,omitempty"`
	// update time, in unix timestamp
	UpdateTimeSec int64 `protobuf:"varint,2,opt,name=update_time_sec,json=UpdateTimeSec,proto3" json:"update_time_sec,omitempty"`
	// read price, in bnb wei per charge byte
	ReadPrice github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,3,opt,name=read_price,json=readPrice,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"read_price"`
	// free read quota, in byte
	FreeReadQuota uint64 `protobuf:"varint,4,opt,name=free_read_quota,json=freeReadQuota,proto3" json:"free_read_quota,omitempty"`
	// store price, in bnb wei per charge byte
	StorePrice github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,5,opt,name=store_price,json=storePrice,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"store_price"`
}

func (m *EventSpStoragePriceUpdate) Reset()         { *m = EventSpStoragePriceUpdate{} }
func (m *EventSpStoragePriceUpdate) String() string { return proto.CompactTextString(m) }
func (*EventSpStoragePriceUpdate) ProtoMessage()    {}
func (*EventSpStoragePriceUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_685cbfa50fdf0841, []int{3}
}
func (m *EventSpStoragePriceUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSpStoragePriceUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSpStoragePriceUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSpStoragePriceUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSpStoragePriceUpdate.Merge(m, src)
}
func (m *EventSpStoragePriceUpdate) XXX_Size() int {
	return m.Size()
}
func (m *EventSpStoragePriceUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSpStoragePriceUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_EventSpStoragePriceUpdate proto.InternalMessageInfo

func (m *EventSpStoragePriceUpdate) GetSpAddress() string {
	if m != nil {
		return m.SpAddress
	}
	return ""
}

func (m *EventSpStoragePriceUpdate) GetUpdateTimeSec() int64 {
	if m != nil {
		return m.UpdateTimeSec
	}
	return 0
}

func (m *EventSpStoragePriceUpdate) GetFreeReadQuota() uint64 {
	if m != nil {
		return m.FreeReadQuota
	}
	return 0
}

type EventSecondarySpStorePriceUpdate struct {
	// update time, in unix timestamp
	UpdateTimeSec int64 `protobuf:"varint,1,opt,name=update_time_sec,json=UpdateTimeSec,proto3" json:"update_time_sec,omitempty"`
	// store price, in bnb wei per charge byte
	StorePrice github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,2,opt,name=store_price,json=storePrice,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"store_price"`
}

func (m *EventSecondarySpStorePriceUpdate) Reset()         { *m = EventSecondarySpStorePriceUpdate{} }
func (m *EventSecondarySpStorePriceUpdate) String() string { return proto.CompactTextString(m) }
func (*EventSecondarySpStorePriceUpdate) ProtoMessage()    {}
func (*EventSecondarySpStorePriceUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_685cbfa50fdf0841, []int{4}
}
func (m *EventSecondarySpStorePriceUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSecondarySpStorePriceUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSecondarySpStorePriceUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSecondarySpStorePriceUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSecondarySpStorePriceUpdate.Merge(m, src)
}
func (m *EventSecondarySpStorePriceUpdate) XXX_Size() int {
	return m.Size()
}
func (m *EventSecondarySpStorePriceUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSecondarySpStorePriceUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_EventSecondarySpStorePriceUpdate proto.InternalMessageInfo

func (m *EventSecondarySpStorePriceUpdate) GetUpdateTimeSec() int64 {
	if m != nil {
		return m.UpdateTimeSec
	}
	return 0
}

func init() {
	proto.RegisterType((*EventCreateStorageProvider)(nil), "bnbchain.greenfield.sp.EventCreateStorageProvider")
	proto.RegisterType((*EventEditStorageProvider)(nil), "bnbchain.greenfield.sp.EventEditStorageProvider")
	proto.RegisterType((*EventDeposit)(nil), "bnbchain.greenfield.sp.EventDeposit")
	proto.RegisterType((*EventSpStoragePriceUpdate)(nil), "bnbchain.greenfield.sp.EventSpStoragePriceUpdate")
	proto.RegisterType((*EventSecondarySpStorePriceUpdate)(nil), "bnbchain.greenfield.sp.EventSecondarySpStorePriceUpdate")
}

func init() { proto.RegisterFile("greenfield/sp/events.proto", fileDescriptor_685cbfa50fdf0841) }

var fileDescriptor_685cbfa50fdf0841 = []byte{
	// 599 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x54, 0xcf, 0x4e, 0x13, 0x41,
	0x18, 0xef, 0x96, 0x3f, 0xca, 0xb4, 0x88, 0xd9, 0x10, 0xb3, 0xf4, 0xb0, 0x40, 0x4d, 0x08, 0x31,
	0xe9, 0x6e, 0xd0, 0x83, 0x07, 0x8d, 0x09, 0x50, 0xee, 0xba, 0xd5, 0x8b, 0xc6, 0xac, 0xb3, 0x3b,
	0x1f, 0xcb, 0xc4, 0x76, 0x66, 0x9c, 0x99, 0x16, 0x79, 0x01, 0xcf, 0xbe, 0x86, 0x77, 0x1e, 0x82,
	0x23, 0xe1, 0x64, 0x3c, 0x10, 0x02, 0xef, 0xe0, 0xd9, 0xec, 0xcc, 0x6c, 0xc1, 0x86, 0xa4, 0x09,
	0xe1, 0xd4, 0xce, 0x37, 0xdf, 0xef, 0xcf, 0xfc, 0x66, 0xf6, 0x43, 0xad, 0x42, 0x02, 0xb0, 0x7d,
	0x0a, 0x7d, 0x12, 0x2b, 0x11, 0xc3, 0x08, 0x98, 0x56, 0x91, 0x90, 0x5c, 0x73, 0xff, 0x49, 0xc6,
	0xb2, 0xfc, 0x00, 0x53, 0x16, 0x5d, 0x37, 0x45, 0x4a, 0xb4, 0xc2, 0x9c, 0xab, 0x01, 0x57, 0x71,
	0x86, 0x15, 0xc4, 0xa3, 0xad, 0x0c, 0x34, 0xde, 0x8a, 0x73, 0x4e, 0x99, 0xc5, 0xb5, 0x56, 0xec,
	0x7e, 0x6a, 0x56, 0xb1, 0x5d, 0xb8, 0xad, 0xe5, 0x82, 0x17, 0xdc, 0xd6, 0xcb, 0x7f, 0xb6, 0xda,
	0xfe, 0x5b, 0x47, 0xad, 0xbd, 0x52, 0x79, 0x57, 0x02, 0xd6, 0xd0, 0xd3, 0x5c, 0xe2, 0x02, 0xde,
	0x4a, 0x3e, 0xa2, 0x04, 0xa4, 0xff, 0x12, 0x21, 0x25, 0x52, 0x4c, 0x88, 0x04, 0xa5, 0x02, 0x6f,
	0xcd, 0xdb, 0x5c, 0xd8, 0x09, 0xce, 0x8e, 0x3b, 0xcb, 0x8e, 0x7a, 0xdb, 0xee, 0xf4, 0xb4, 0xa4,
	0xac, 0x48, 0x16, 0x94, 0x70, 0x05, 0x7f, 0x1b, 0x2d, 0xed, 0x0f, 0x19, 0xa1, 0xac, 0x18, 0xa3,
	0xeb, 0x53, 0xd0, 0x8f, 0x1c, 0xa0, 0xa2, 0x78, 0x85, 0x9a, 0x0a, 0x70, 0x7f, 0x8c, 0x9f, 0x99,
	0x82, 0x6f, 0x94, 0xdd, 0x15, 0x78, 0x17, 0x3d, 0xc6, 0x42, 0x48, 0x3e, 0xba, 0x41, 0x30, 0x3b,
	0x85, 0x60, 0xa9, 0x42, 0x54, 0x24, 0x2d, 0xf4, 0x10, 0x18, 0x11, 0x9c, 0x32, 0x1d, 0xcc, 0x95,
	0xe0, 0x64, 0xbc, 0xf6, 0xdf, 0xa0, 0x45, 0xcd, 0x35, 0xee, 0xa7, 0x04, 0x04, 0x57, 0x54, 0x07,
	0xf3, 0x6b, 0xde, 0x66, 0xe3, 0xf9, 0x4a, 0xe4, 0xa8, 0xcb, 0x1b, 0x8a, 0xdc, 0x0d, 0x45, 0xbb,
	0x9c, 0xb2, 0xa4, 0x69, 0xfa, 0xbb, 0xb6, 0xbd, 0xfd, 0x05, 0x05, 0x26, 0xf7, 0x3d, 0x42, 0xf5,
	0x64, 0xea, 0xeb, 0xa8, 0xc9, 0xfb, 0x24, 0x1d, 0x6b, 0x9b, 0xdc, 0x93, 0x06, 0xef, 0x93, 0xbd,
	0x4a, 0x7e, 0x1d, 0x35, 0x19, 0x1c, 0x5e, 0xb7, 0xd4, 0x6d, 0x0b, 0x83, 0xc3, 0xaa, 0xa5, 0xfd,
	0xc3, 0x43, 0x4d, 0x23, 0xe1, 0x24, 0xef, 0x7e, 0x99, 0x01, 0x7a, 0x50, 0x9d, 0xd2, 0xea, 0x54,
	0x4b, 0xff, 0xe9, 0x64, 0x0a, 0xe6, 0x92, 0x26, 0x8e, 0x7a, 0x51, 0x47, 0x2b, 0xc6, 0x48, 0x4f,
	0x8c, 0x4f, 0x4a, 0x73, 0xf8, 0x20, 0x08, 0xd6, 0x70, 0x77, 0x57, 0x1b, 0x68, 0x69, 0x68, 0x28,
	0x52, 0x4d, 0x07, 0x90, 0x2a, 0xc8, 0x8d, 0xbb, 0x99, 0x64, 0xd1, 0x96, 0xdf, 0xd3, 0x01, 0xf4,
	0x20, 0xf7, 0x3f, 0x21, 0x24, 0x01, 0x93, 0x54, 0x94, 0xa2, 0xee, 0x15, 0xbd, 0x3e, 0x39, 0x5f,
	0xad, 0xfd, 0x39, 0x5f, 0xdd, 0x28, 0xa8, 0x3e, 0x18, 0x66, 0x51, 0xce, 0x07, 0xee, 0x6b, 0x71,
	0x3f, 0x1d, 0x45, 0xbe, 0xc6, 0xfa, 0x48, 0x80, 0x8a, 0xba, 0x90, 0x9f, 0x1d, 0x77, 0x90, 0xb3,
	0xd3, 0x85, 0x3c, 0x59, 0x28, 0xf9, 0xcc, 0x19, 0x4a, 0x13, 0xfb, 0x12, 0x20, 0x35, 0x0a, 0xdf,
	0x86, 0x5c, 0x63, 0xf3, 0xcc, 0x66, 0x93, 0xc5, 0xb2, 0x9c, 0x00, 0x26, 0xef, 0xca, 0xa2, 0xff,
	0x19, 0x35, 0x94, 0xe6, 0x12, 0x9c, 0x8b, 0xb9, 0x7b, 0x70, 0x81, 0x0c, 0xa1, 0xb1, 0xd1, 0xfe,
	0xe5, 0xa1, 0x35, 0x1b, 0x31, 0xe4, 0x9c, 0x11, 0x2c, 0x8f, 0x6c, 0xd6, 0xff, 0x25, 0x7d, 0x4b,
	0x60, 0xde, 0x6d, 0x81, 0x4d, 0x78, 0xad, 0xdf, 0xaf, 0xd7, 0x9d, 0xee, 0xc9, 0x65, 0xe8, 0x9d,
	0x5e, 0x86, 0xde, 0xc5, 0x65, 0xe8, 0xfd, 0xbc, 0x0a, 0x6b, 0xa7, 0x57, 0x61, 0xed, 0xf7, 0x55,
	0x58, 0xfb, 0xf8, 0xec, 0x06, 0x77, 0xc6, 0xb2, 0x8e, 0x99, 0x80, 0xf1, 0x8d, 0x31, 0xf9, 0xbd,
	0x1c, 0x94, 0x46, 0x23, 0x9b, 0x37, 0xf3, 0xeb, 0xc5, 0xbf, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,
	0xdf, 0xd3, 0x61, 0x46, 0x05, 0x00, 0x00,
}

func (m *EventCreateStorageProvider) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventCreateStorageProvider) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventCreateStorageProvider) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TotalDeposit != nil {
		{
			size, err := m.TotalDeposit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Endpoint) > 0 {
		i -= len(m.Endpoint)
		copy(dAtA[i:], m.Endpoint)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Endpoint)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ApprovalAddress) > 0 {
		i -= len(m.ApprovalAddress)
		copy(dAtA[i:], m.ApprovalAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.ApprovalAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.SealAddress) > 0 {
		i -= len(m.SealAddress)
		copy(dAtA[i:], m.SealAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.SealAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.FundingAddress) > 0 {
		i -= len(m.FundingAddress)
		copy(dAtA[i:], m.FundingAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.FundingAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SpAddress) > 0 {
		i -= len(m.SpAddress)
		copy(dAtA[i:], m.SpAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.SpAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventEditStorageProvider) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventEditStorageProvider) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventEditStorageProvider) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NewEndpoint) > 0 {
		i -= len(m.NewEndpoint)
		copy(dAtA[i:], m.NewEndpoint)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.NewEndpoint)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.OldEndpoint) > 0 {
		i -= len(m.OldEndpoint)
		copy(dAtA[i:], m.OldEndpoint)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.OldEndpoint)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventDeposit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventDeposit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventDeposit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TotalDeposit) > 0 {
		i -= len(m.TotalDeposit)
		copy(dAtA[i:], m.TotalDeposit)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.TotalDeposit)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Deposit) > 0 {
		i -= len(m.Deposit)
		copy(dAtA[i:], m.Deposit)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Deposit)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SpAddress) > 0 {
		i -= len(m.SpAddress)
		copy(dAtA[i:], m.SpAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.SpAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSpStoragePriceUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSpStoragePriceUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSpStoragePriceUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.StorePrice.Size()
		i -= size
		if _, err := m.StorePrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.FreeReadQuota != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.FreeReadQuota))
		i--
		dAtA[i] = 0x20
	}
	{
		size := m.ReadPrice.Size()
		i -= size
		if _, err := m.ReadPrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.UpdateTimeSec != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.UpdateTimeSec))
		i--
		dAtA[i] = 0x10
	}
	if len(m.SpAddress) > 0 {
		i -= len(m.SpAddress)
		copy(dAtA[i:], m.SpAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.SpAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSecondarySpStorePriceUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSecondarySpStorePriceUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSecondarySpStorePriceUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.StorePrice.Size()
		i -= size
		if _, err := m.StorePrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.UpdateTimeSec != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.UpdateTimeSec))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintEvents(dAtA []byte, offset int, v uint64) int {
	offset -= sovEvents(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *EventCreateStorageProvider) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SpAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.FundingAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.SealAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.ApprovalAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Endpoint)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.TotalDeposit != nil {
		l = m.TotalDeposit.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventEditStorageProvider) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OldEndpoint)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.NewEndpoint)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventDeposit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SpAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Deposit)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.TotalDeposit)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventSpStoragePriceUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SpAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.UpdateTimeSec != 0 {
		n += 1 + sovEvents(uint64(m.UpdateTimeSec))
	}
	l = m.ReadPrice.Size()
	n += 1 + l + sovEvents(uint64(l))
	if m.FreeReadQuota != 0 {
		n += 1 + sovEvents(uint64(m.FreeReadQuota))
	}
	l = m.StorePrice.Size()
	n += 1 + l + sovEvents(uint64(l))
	return n
}

func (m *EventSecondarySpStorePriceUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UpdateTimeSec != 0 {
		n += 1 + sovEvents(uint64(m.UpdateTimeSec))
	}
	l = m.StorePrice.Size()
	n += 1 + l + sovEvents(uint64(l))
	return n
}

func sovEvents(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozEvents(x uint64) (n int) {
	return sovEvents(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EventCreateStorageProvider) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventCreateStorageProvider: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventCreateStorageProvider: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FundingAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FundingAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SealAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SealAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApprovalAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Endpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalDeposit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TotalDeposit == nil {
				m.TotalDeposit = &types.Coin{}
			}
			if err := m.TotalDeposit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventEditStorageProvider) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventEditStorageProvider: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventEditStorageProvider: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldEndpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OldEndpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewEndpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewEndpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventDeposit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventDeposit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventDeposit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deposit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Deposit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalDeposit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalDeposit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSpStoragePriceUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSpStoragePriceUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSpStoragePriceUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateTimeSec", wireType)
			}
			m.UpdateTimeSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateTimeSec |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReadPrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FreeReadQuota", wireType)
			}
			m.FreeReadQuota = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FreeReadQuota |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorePrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StorePrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSecondarySpStorePriceUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSecondarySpStorePriceUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSecondarySpStorePriceUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateTimeSec", wireType)
			}
			m.UpdateTimeSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateTimeSec |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorePrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StorePrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEvents(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthEvents
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupEvents
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthEvents
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthEvents        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEvents          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupEvents = fmt.Errorf("proto: unexpected end of group")
)
