// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: greenfield/storage/common.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// SourceType represents the source of resource creation, which can
// from Greenfield native or from a cross-chain transfer from BSC
type SourceType int32

const (
	SOURCE_TYPE_ORIGIN          SourceType = 0
	SOURCE_TYPE_BSC_CROSS_CHAIN SourceType = 1
	SOURCE_TYPE_MIRROR_PENDING  SourceType = 2
)

var SourceType_name = map[int32]string{
	0: "SOURCE_TYPE_ORIGIN",
	1: "SOURCE_TYPE_BSC_CROSS_CHAIN",
	2: "SOURCE_TYPE_MIRROR_PENDING",
}

var SourceType_value = map[string]int32{
	"SOURCE_TYPE_ORIGIN":          0,
	"SOURCE_TYPE_BSC_CROSS_CHAIN": 1,
	"SOURCE_TYPE_MIRROR_PENDING":  2,
}

func (x SourceType) String() string {
	return proto.EnumName(SourceType_name, int32(x))
}

func (SourceType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4eff6c0fa4aaf4c9, []int{0}
}

// BucketStatus represents the status of a bucket. After a user successfully
// sends a CreateBucket transaction onto the chain, the status is set to 'Created'.
// When a Discontinue Object transaction is received on chain, the status is set to 'Discontinued'.
type BucketStatus int32

const (
	BUCKET_STATUS_CREATED      BucketStatus = 0
	BUCKET_STATUS_DISCONTINUED BucketStatus = 1
)

var BucketStatus_name = map[int32]string{
	0: "BUCKET_STATUS_CREATED",
	1: "BUCKET_STATUS_DISCONTINUED",
}

var BucketStatus_value = map[string]int32{
	"BUCKET_STATUS_CREATED":      0,
	"BUCKET_STATUS_DISCONTINUED": 1,
}

func (x BucketStatus) String() string {
	return proto.EnumName(BucketStatus_name, int32(x))
}

func (BucketStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4eff6c0fa4aaf4c9, []int{1}
}

// RedundancyType represents the redundancy algorithm type for object data,
// which can be either multi-replica or erasure coding.
type RedundancyType int32

const (
	REDUNDANCY_EC_TYPE      RedundancyType = 0
	REDUNDANCY_REPLICA_TYPE RedundancyType = 1
)

var RedundancyType_name = map[int32]string{
	0: "REDUNDANCY_EC_TYPE",
	1: "REDUNDANCY_REPLICA_TYPE",
}

var RedundancyType_value = map[string]int32{
	"REDUNDANCY_EC_TYPE":      0,
	"REDUNDANCY_REPLICA_TYPE": 1,
}

func (x RedundancyType) String() string {
	return proto.EnumName(RedundancyType_name, int32(x))
}

func (RedundancyType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4eff6c0fa4aaf4c9, []int{2}
}

// ObjectStatus represents the creation status of an object. After a user successfully
// sends a CreateObject transaction onto the chain, the status is set to 'Created'.
// After the Primary Service Provider successfully sends a Seal Object transaction onto
// the chain, the status is set to 'Sealed'. When a Discontinue Object transaction is
// received on chain, the status is set to 'Discontinued'.
type ObjectStatus int32

const (
	OBJECT_STATUS_CREATED      ObjectStatus = 0
	OBJECT_STATUS_SEALED       ObjectStatus = 1
	OBJECT_STATUS_DISCONTINUED ObjectStatus = 2
)

var ObjectStatus_name = map[int32]string{
	0: "OBJECT_STATUS_CREATED",
	1: "OBJECT_STATUS_SEALED",
	2: "OBJECT_STATUS_DISCONTINUED",
}

var ObjectStatus_value = map[string]int32{
	"OBJECT_STATUS_CREATED":      0,
	"OBJECT_STATUS_SEALED":       1,
	"OBJECT_STATUS_DISCONTINUED": 2,
}

func (x ObjectStatus) String() string {
	return proto.EnumName(ObjectStatus_name, int32(x))
}

func (ObjectStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4eff6c0fa4aaf4c9, []int{3}
}

// VisibilityType is the resources public status.
type VisibilityType int32

const (
	VISIBILITY_TYPE_UNSPECIFIED VisibilityType = 0
	VISIBILITY_TYPE_PUBLIC_READ VisibilityType = 1
	VISIBILITY_TYPE_PRIVATE     VisibilityType = 2
	// If the bucket Visibility is inherit, it's finally set to private. If the object Visibility is inherit, it's the same as bucket.
	VISIBILITY_TYPE_INHERIT VisibilityType = 3
)

var VisibilityType_name = map[int32]string{
	0: "VISIBILITY_TYPE_UNSPECIFIED",
	1: "VISIBILITY_TYPE_PUBLIC_READ",
	2: "VISIBILITY_TYPE_PRIVATE",
	3: "VISIBILITY_TYPE_INHERIT",
}

var VisibilityType_value = map[string]int32{
	"VISIBILITY_TYPE_UNSPECIFIED": 0,
	"VISIBILITY_TYPE_PUBLIC_READ": 1,
	"VISIBILITY_TYPE_PRIVATE":     2,
	"VISIBILITY_TYPE_INHERIT":     3,
}

func (x VisibilityType) String() string {
	return proto.EnumName(VisibilityType_name, int32(x))
}

func (VisibilityType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4eff6c0fa4aaf4c9, []int{4}
}

// Approval is the signature information returned by the Primary Storage Provider (SP) to the user
// after allowing them to create a bucket or object, which is then used for verification on the chain
// to ensure agreement between the Primary SP and the user."
type Approval struct {
	// expired_height is the block height at which the signature expires.
	ExpiredHeight uint64 `protobuf:"varint,1,opt,name=expired_height,json=expiredHeight,proto3" json:"expired_height,omitempty"`
	// The signature needs to conform to the EIP 712 specification.
	Sig []byte `protobuf:"bytes,2,opt,name=sig,proto3" json:"sig,omitempty"`
}

func (m *Approval) Reset()         { *m = Approval{} }
func (m *Approval) String() string { return proto.CompactTextString(m) }
func (*Approval) ProtoMessage()    {}
func (*Approval) Descriptor() ([]byte, []int) {
	return fileDescriptor_4eff6c0fa4aaf4c9, []int{0}
}
func (m *Approval) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Approval) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Approval.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Approval) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Approval.Merge(m, src)
}
func (m *Approval) XXX_Size() int {
	return m.Size()
}
func (m *Approval) XXX_DiscardUnknown() {
	xxx_messageInfo_Approval.DiscardUnknown(m)
}

var xxx_messageInfo_Approval proto.InternalMessageInfo

func (m *Approval) GetExpiredHeight() uint64 {
	if m != nil {
		return m.ExpiredHeight
	}
	return 0
}

func (m *Approval) GetSig() []byte {
	if m != nil {
		return m.Sig
	}
	return nil
}

// SecondarySpSignDoc used to generate seal signature of secondary SP
// If the secondary SP only signs the checksum to declare the object pieces are saved,
// it might be reused by the primary SP to fake it's declaration.
// Then the primary SP can challenge and slash the secondary SP.
// So the id of the object is needed to prevent this.
type SecondarySpSignDoc struct {
	SpAddress string `protobuf:"bytes,1,opt,name=sp_address,json=spAddress,proto3" json:"sp_address,omitempty"`
	ObjectId  Uint   `protobuf:"bytes,2,opt,name=object_id,json=objectId,proto3,customtype=Uint" json:"object_id"`
	Checksum  []byte `protobuf:"bytes,3,opt,name=checksum,proto3" json:"checksum,omitempty"`
}

func (m *SecondarySpSignDoc) Reset()         { *m = SecondarySpSignDoc{} }
func (m *SecondarySpSignDoc) String() string { return proto.CompactTextString(m) }
func (*SecondarySpSignDoc) ProtoMessage()    {}
func (*SecondarySpSignDoc) Descriptor() ([]byte, []int) {
	return fileDescriptor_4eff6c0fa4aaf4c9, []int{1}
}
func (m *SecondarySpSignDoc) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecondarySpSignDoc) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecondarySpSignDoc.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecondarySpSignDoc) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecondarySpSignDoc.Merge(m, src)
}
func (m *SecondarySpSignDoc) XXX_Size() int {
	return m.Size()
}
func (m *SecondarySpSignDoc) XXX_DiscardUnknown() {
	xxx_messageInfo_SecondarySpSignDoc.DiscardUnknown(m)
}

var xxx_messageInfo_SecondarySpSignDoc proto.InternalMessageInfo

func (m *SecondarySpSignDoc) GetSpAddress() string {
	if m != nil {
		return m.SpAddress
	}
	return ""
}

func (m *SecondarySpSignDoc) GetChecksum() []byte {
	if m != nil {
		return m.Checksum
	}
	return nil
}

func init() {
	proto.RegisterEnum("bnbchain.greenfield.storage.SourceType", SourceType_name, SourceType_value)
	proto.RegisterEnum("bnbchain.greenfield.storage.BucketStatus", BucketStatus_name, BucketStatus_value)
	proto.RegisterEnum("bnbchain.greenfield.storage.RedundancyType", RedundancyType_name, RedundancyType_value)
	proto.RegisterEnum("bnbchain.greenfield.storage.ObjectStatus", ObjectStatus_name, ObjectStatus_value)
	proto.RegisterEnum("bnbchain.greenfield.storage.VisibilityType", VisibilityType_name, VisibilityType_value)
	proto.RegisterType((*Approval)(nil), "bnbchain.greenfield.storage.Approval")
	proto.RegisterType((*SecondarySpSignDoc)(nil), "bnbchain.greenfield.storage.SecondarySpSignDoc")
}

func init() { proto.RegisterFile("greenfield/storage/common.proto", fileDescriptor_4eff6c0fa4aaf4c9) }

var fileDescriptor_4eff6c0fa4aaf4c9 = []byte{
	// 616 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x93, 0x4f, 0x4e, 0xdb, 0x40,
	0x14, 0xc6, 0x6d, 0x40, 0x15, 0x99, 0x52, 0x64, 0x59, 0xb4, 0x84, 0x44, 0x72, 0x10, 0x52, 0x25,
	0x84, 0x44, 0xb2, 0xe8, 0xa2, 0xdd, 0xda, 0x93, 0x29, 0x4c, 0x49, 0xed, 0x68, 0xc6, 0x46, 0xa2,
	0x9b, 0x91, 0xff, 0x4c, 0x9d, 0x29, 0xc4, 0x63, 0xd9, 0x4e, 0x45, 0x6e, 0xd0, 0x65, 0xd5, 0x2b,
	0x70, 0x05, 0x0e, 0xc1, 0x12, 0xb1, 0xaa, 0xba, 0x40, 0x15, 0x5c, 0xa4, 0xb2, 0x1d, 0x20, 0x51,
	0xd9, 0xcd, 0xfb, 0xbe, 0xcf, 0xef, 0xfd, 0xfc, 0xa4, 0x07, 0x3a, 0x71, 0xc6, 0x79, 0xf2, 0x55,
	0xf0, 0xb3, 0xa8, 0x97, 0x17, 0x32, 0xf3, 0x63, 0xde, 0x0b, 0xe5, 0x78, 0x2c, 0x93, 0x6e, 0x9a,
	0xc9, 0x42, 0xea, 0xed, 0x20, 0x09, 0xc2, 0x91, 0x2f, 0x92, 0xee, 0x53, 0xb2, 0x3b, 0x4b, 0xb6,
	0xb6, 0x42, 0x99, 0x8f, 0x65, 0xce, 0xaa, 0x68, 0xaf, 0x2e, 0xea, 0xef, 0x5a, 0x1b, 0xb1, 0x8c,
	0x65, 0xad, 0x97, 0xaf, 0x5a, 0xdd, 0x81, 0x60, 0xd5, 0x4c, 0xd3, 0x4c, 0x7e, 0xf7, 0xcf, 0xf4,
	0xb7, 0x60, 0x9d, 0x9f, 0xa7, 0x22, 0xe3, 0x11, 0x1b, 0x71, 0x11, 0x8f, 0x8a, 0xa6, 0xba, 0xad,
	0xee, 0xae, 0x90, 0x57, 0x33, 0xf5, 0xb0, 0x12, 0x75, 0x0d, 0x2c, 0xe7, 0x22, 0x6e, 0x2e, 0x6d,
	0xab, 0xbb, 0x6b, 0xa4, 0x7c, 0xee, 0x5c, 0xa8, 0x40, 0xa7, 0x3c, 0x94, 0x49, 0xe4, 0x67, 0x53,
	0x9a, 0x52, 0x11, 0x27, 0x7d, 0x19, 0xea, 0xef, 0x01, 0xc8, 0x53, 0xe6, 0x47, 0x51, 0xc6, 0xf3,
	0xbc, 0xea, 0xd5, 0xb0, 0x9a, 0x37, 0x97, 0xfb, 0x1b, 0x33, 0x2e, 0xb3, 0x76, 0x68, 0x91, 0x89,
	0x24, 0x26, 0x8d, 0x3c, 0x9d, 0x09, 0xfa, 0x07, 0xd0, 0x90, 0xc1, 0x37, 0x1e, 0x16, 0x4c, 0x44,
	0xd5, 0x9c, 0x86, 0xd5, 0xbe, 0xba, 0xed, 0x28, 0x7f, 0x6e, 0x3b, 0x2b, 0x9e, 0x48, 0x8a, 0x9b,
	0xcb, 0xfd, 0x97, 0xb3, 0x1e, 0x65, 0x49, 0x56, 0xeb, 0x34, 0x8e, 0xf4, 0x16, 0x58, 0x0d, 0x47,
	0x3c, 0x3c, 0xcd, 0x27, 0xe3, 0xe6, 0x72, 0x05, 0xf8, 0x58, 0xef, 0x9d, 0x02, 0x40, 0xe5, 0x24,
	0x0b, 0xb9, 0x3b, 0x4d, 0xb9, 0xfe, 0x06, 0xe8, 0xd4, 0xf1, 0x08, 0x44, 0xcc, 0x3d, 0x19, 0x22,
	0xe6, 0x10, 0x7c, 0x80, 0x6d, 0x4d, 0xd1, 0x3b, 0xa0, 0x3d, 0xaf, 0x5b, 0x14, 0x32, 0x48, 0x1c,
	0x4a, 0x19, 0x3c, 0x34, 0xb1, 0xad, 0xa9, 0xba, 0x01, 0x5a, 0xf3, 0x81, 0xcf, 0x98, 0x10, 0x87,
	0xb0, 0x21, 0xb2, 0xfb, 0xd8, 0x3e, 0xd0, 0x96, 0x5a, 0x2b, 0x3f, 0x2e, 0x0c, 0x65, 0xcf, 0x01,
	0x6b, 0xd6, 0x24, 0x3c, 0xe5, 0x05, 0x2d, 0xfc, 0x62, 0x92, 0xeb, 0x5b, 0xe0, 0xb5, 0xe5, 0xc1,
	0x23, 0xe4, 0x32, 0xea, 0x9a, 0xae, 0x47, 0x19, 0x24, 0xc8, 0x74, 0x51, 0x5f, 0x53, 0xca, 0x86,
	0x8b, 0x56, 0x1f, 0x53, 0xe8, 0xd8, 0x2e, 0xb6, 0x3d, 0xd4, 0xd7, 0xd4, 0x59, 0xc3, 0x23, 0xb0,
	0x4e, 0x78, 0x34, 0x49, 0x22, 0x3f, 0x09, 0xa7, 0x0f, 0x7f, 0x40, 0x50, 0xdf, 0xb3, 0xfb, 0xa6,
	0x0d, 0x4f, 0x18, 0x82, 0x15, 0x8f, 0xa6, 0xe8, 0x6d, 0xb0, 0x39, 0xa7, 0x13, 0x34, 0x1c, 0x60,
	0x68, 0xd6, 0xe6, 0x43, 0x33, 0x01, 0xd6, 0x9c, 0x6a, 0x65, 0x4f, 0x74, 0x8e, 0xf5, 0x09, 0xc1,
	0x67, 0xe8, 0x9a, 0x60, 0x63, 0xd1, 0xa2, 0xc8, 0x1c, 0x94, 0x5c, 0x25, 0xf7, 0xa2, 0xb3, 0xc0,
	0xfd, 0xb0, 0x88, 0x5f, 0x2a, 0x58, 0x3f, 0x16, 0xb9, 0x08, 0xc4, 0x99, 0x28, 0x6a, 0xf0, 0x0e,
	0x68, 0x1f, 0x63, 0x8a, 0x2d, 0x3c, 0xc0, 0xee, 0x49, 0xbd, 0x45, 0xcf, 0xa6, 0x43, 0x04, 0xf1,
	0x47, 0x5c, 0xcd, 0x7c, 0x26, 0x30, 0xf4, 0xac, 0x01, 0x86, 0x8c, 0x20, 0xb3, 0x1c, 0xdd, 0x06,
	0x9b, 0xff, 0x05, 0x08, 0x3e, 0x36, 0x5d, 0xa4, 0x2d, 0x3d, 0x67, 0x62, 0xfb, 0x10, 0x11, 0xec,
	0x6a, 0xcb, 0x35, 0x94, 0x85, 0xaf, 0xee, 0x0c, 0xf5, 0xfa, 0xce, 0x50, 0xff, 0xde, 0x19, 0xea,
	0xcf, 0x7b, 0x43, 0xb9, 0xbe, 0x37, 0x94, 0xdf, 0xf7, 0x86, 0xf2, 0xa5, 0x17, 0x8b, 0x62, 0x34,
	0x09, 0xba, 0xa1, 0x1c, 0xf7, 0x82, 0x24, 0xd8, 0xaf, 0x2e, 0xad, 0x37, 0x77, 0x93, 0xe7, 0x8f,
	0x57, 0x59, 0x4c, 0x53, 0x9e, 0x07, 0x2f, 0xaa, 0x3b, 0x7a, 0xf7, 0x2f, 0x00, 0x00, 0xff, 0xff,
	0xbb, 0x78, 0x69, 0x4b, 0xb8, 0x03, 0x00, 0x00,
}

func (m *Approval) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Approval) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Approval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sig) > 0 {
		i -= len(m.Sig)
		copy(dAtA[i:], m.Sig)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Sig)))
		i--
		dAtA[i] = 0x12
	}
	if m.ExpiredHeight != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.ExpiredHeight))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SecondarySpSignDoc) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecondarySpSignDoc) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecondarySpSignDoc) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Checksum) > 0 {
		i -= len(m.Checksum)
		copy(dAtA[i:], m.Checksum)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Checksum)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size := m.ObjectId.Size()
		i -= size
		if _, err := m.ObjectId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCommon(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.SpAddress) > 0 {
		i -= len(m.SpAddress)
		copy(dAtA[i:], m.SpAddress)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.SpAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintCommon(dAtA []byte, offset int, v uint64) int {
	offset -= sovCommon(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Approval) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExpiredHeight != 0 {
		n += 1 + sovCommon(uint64(m.ExpiredHeight))
	}
	l = len(m.Sig)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}

func (m *SecondarySpSignDoc) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SpAddress)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = m.ObjectId.Size()
	n += 1 + l + sovCommon(uint64(l))
	l = len(m.Checksum)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}

func sovCommon(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCommon(x uint64) (n int) {
	return sovCommon(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Approval) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Approval: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Approval: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiredHeight", wireType)
			}
			m.ExpiredHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiredHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sig = append(m.Sig[:0], dAtA[iNdEx:postIndex]...)
			if m.Sig == nil {
				m.Sig = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecondarySpSignDoc) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecondarySpSignDoc: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecondarySpSignDoc: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checksum", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Checksum = append(m.Checksum[:0], dAtA[iNdEx:postIndex]...)
			if m.Checksum == nil {
				m.Checksum = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCommon(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCommon
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCommon
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCommon
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCommon        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCommon          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCommon = fmt.Errorf("proto: unexpected end of group")
)
