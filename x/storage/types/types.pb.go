// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: greenfield/storage/types.proto

package types

import (
	fmt "fmt"
	_ "github.com/bnb-chain/greenfield/x/payment/types"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type BucketInfo struct {
	// owner is the account address of bucket creator, it is also the bucket owner.
	Owner string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	// bucket_name is a globally unique name of bucket
	BucketName string `protobuf:"bytes,2,opt,name=bucket_name,json=bucketName,proto3" json:"bucket_name,omitempty"`
	// visibility defines the highest permissions for bucket. When a bucket is public, everyone can get storage objects in it.
	Visibility VisibilityType `protobuf:"varint,3,opt,name=visibility,proto3,enum=greenfield.storage.VisibilityType" json:"visibility,omitempty"`
	// id is the unique identification for bucket.
	Id Uint `protobuf:"bytes,4,opt,name=id,proto3,customtype=Uint" json:"id"`
	// source_type defines which chain the user should send the bucket management transactions to
	SourceType SourceType `protobuf:"varint,5,opt,name=source_type,json=sourceType,proto3,enum=greenfield.storage.SourceType" json:"source_type,omitempty"`
	// create_at define the block timestamp when the bucket created.
	CreateAt int64 `protobuf:"varint,6,opt,name=create_at,json=createAt,proto3" json:"create_at,omitempty"`
	// payment_address is the address of the payment account
	PaymentAddress string `protobuf:"bytes,7,opt,name=payment_address,json=paymentAddress,proto3" json:"payment_address,omitempty"`
	// primary_sp_id is the unique id of the primary sp. Objects belongs to this bucket will never
	// leave this SP, unless you explicitly shift them to another SP.
	PrimarySpId uint32 `protobuf:"varint,8,opt,name=primary_sp_id,json=primarySpId,proto3" json:"primary_sp_id,omitempty"`
	// global_virtual_group_family_id defines the unique id of gvg family
	GlobalVirtualGroupFamilyId uint32 `protobuf:"varint,9,opt,name=global_virtual_group_family_id,json=globalVirtualGroupFamilyId,proto3" json:"global_virtual_group_family_id,omitempty"`
	// charged_read_quota defines the traffic quota for read in bytes per month.
	// The available read data for each user is the sum of the free read data provided by SP and
	// the ChargeReadQuota specified here.
	ChargedReadQuota uint64 `protobuf:"varint,10,opt,name=charged_read_quota,json=chargedReadQuota,proto3" json:"charged_read_quota,omitempty"`
	// bucket_status define the status of the bucket.
	BucketStatus BucketStatus `protobuf:"varint,11,opt,name=bucket_status,json=bucketStatus,proto3,enum=greenfield.storage.BucketStatus" json:"bucket_status,omitempty"`
}

func (m *BucketInfo) Reset()         { *m = BucketInfo{} }
func (m *BucketInfo) String() string { return proto.CompactTextString(m) }
func (*BucketInfo) ProtoMessage()    {}
func (*BucketInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf95fa2efdc74d97, []int{0}
}
func (m *BucketInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BucketInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BucketInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BucketInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BucketInfo.Merge(m, src)
}
func (m *BucketInfo) XXX_Size() int {
	return m.Size()
}
func (m *BucketInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_BucketInfo.DiscardUnknown(m)
}

var xxx_messageInfo_BucketInfo proto.InternalMessageInfo

func (m *BucketInfo) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *BucketInfo) GetBucketName() string {
	if m != nil {
		return m.BucketName
	}
	return ""
}

func (m *BucketInfo) GetVisibility() VisibilityType {
	if m != nil {
		return m.Visibility
	}
	return VISIBILITY_TYPE_UNSPECIFIED
}

func (m *BucketInfo) GetSourceType() SourceType {
	if m != nil {
		return m.SourceType
	}
	return SOURCE_TYPE_ORIGIN
}

func (m *BucketInfo) GetCreateAt() int64 {
	if m != nil {
		return m.CreateAt
	}
	return 0
}

func (m *BucketInfo) GetPaymentAddress() string {
	if m != nil {
		return m.PaymentAddress
	}
	return ""
}

func (m *BucketInfo) GetPrimarySpId() uint32 {
	if m != nil {
		return m.PrimarySpId
	}
	return 0
}

func (m *BucketInfo) GetGlobalVirtualGroupFamilyId() uint32 {
	if m != nil {
		return m.GlobalVirtualGroupFamilyId
	}
	return 0
}

func (m *BucketInfo) GetChargedReadQuota() uint64 {
	if m != nil {
		return m.ChargedReadQuota
	}
	return 0
}

func (m *BucketInfo) GetBucketStatus() BucketStatus {
	if m != nil {
		return m.BucketStatus
	}
	return BUCKET_STATUS_CREATED
}

type InternalBucketInfo struct {
	// the time of the payment price, used to calculate the charge rate of the bucket
	PriceTime int64 `protobuf:"varint,1,opt,name=price_time,json=priceTime,proto3" json:"price_time,omitempty"`
	// the total size of the objects in the bucket, used to calculate the charge rate of the bucket
	TotalChargeSize uint64 `protobuf:"varint,2,opt,name=total_charge_size,json=totalChargeSize,proto3" json:"total_charge_size,omitempty"`
	// local_virtual_groups contains all the lvg of this bucket.
	LocalVirtualGroups []*LocalVirtualGroup `protobuf:"bytes,3,rep,name=local_virtual_groups,json=localVirtualGroups,proto3" json:"local_virtual_groups,omitempty"`
	// next_local_virtual_group_id store the next id used by local virtual group
	NextLocalVirtualGroupId uint32 `protobuf:"varint,4,opt,name=next_local_virtual_group_id,json=nextLocalVirtualGroupId,proto3" json:"next_local_virtual_group_id,omitempty"`
}

func (m *InternalBucketInfo) Reset()         { *m = InternalBucketInfo{} }
func (m *InternalBucketInfo) String() string { return proto.CompactTextString(m) }
func (*InternalBucketInfo) ProtoMessage()    {}
func (*InternalBucketInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf95fa2efdc74d97, []int{1}
}
func (m *InternalBucketInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InternalBucketInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InternalBucketInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InternalBucketInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InternalBucketInfo.Merge(m, src)
}
func (m *InternalBucketInfo) XXX_Size() int {
	return m.Size()
}
func (m *InternalBucketInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_InternalBucketInfo.DiscardUnknown(m)
}

var xxx_messageInfo_InternalBucketInfo proto.InternalMessageInfo

func (m *InternalBucketInfo) GetPriceTime() int64 {
	if m != nil {
		return m.PriceTime
	}
	return 0
}

func (m *InternalBucketInfo) GetTotalChargeSize() uint64 {
	if m != nil {
		return m.TotalChargeSize
	}
	return 0
}

func (m *InternalBucketInfo) GetLocalVirtualGroups() []*LocalVirtualGroup {
	if m != nil {
		return m.LocalVirtualGroups
	}
	return nil
}

func (m *InternalBucketInfo) GetNextLocalVirtualGroupId() uint32 {
	if m != nil {
		return m.NextLocalVirtualGroupId
	}
	return 0
}

type ObjectInfo struct {
	// owner is the object owner
	Owner string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	// creator is the address of the uploader, it always be same as owner address
	Creator string `protobuf:"bytes,2,opt,name=creator,proto3" json:"creator,omitempty"`
	// bucket_name is the name of the bucket
	BucketName string `protobuf:"bytes,3,opt,name=bucket_name,json=bucketName,proto3" json:"bucket_name,omitempty"`
	// object_name is the name of object
	ObjectName string `protobuf:"bytes,4,opt,name=object_name,json=objectName,proto3" json:"object_name,omitempty"`
	// id is the unique identifier of object
	Id                  Uint   `protobuf:"bytes,5,opt,name=id,proto3,customtype=Uint" json:"id"`
	LocalVirtualGroupId uint32 `protobuf:"varint,6,opt,name=local_virtual_group_id,json=localVirtualGroupId,proto3" json:"local_virtual_group_id,omitempty"`
	// payloadSize is the total size of the object payload
	PayloadSize uint64 `protobuf:"varint,7,opt,name=payload_size,json=payloadSize,proto3" json:"payload_size,omitempty"`
	// visibility defines the highest permissions for object. When an object is public, everyone can access it.
	Visibility VisibilityType `protobuf:"varint,8,opt,name=visibility,proto3,enum=greenfield.storage.VisibilityType" json:"visibility,omitempty"`
	// content_type define the format of the object which should be a standard MIME type.
	ContentType string `protobuf:"bytes,9,opt,name=content_type,json=contentType,proto3" json:"content_type,omitempty"`
	// create_at define the block timestamp when the object is created
	CreateAt int64 `protobuf:"varint,10,opt,name=create_at,json=createAt,proto3" json:"create_at,omitempty"`
	// object_status define the upload status of the object.
	ObjectStatus ObjectStatus `protobuf:"varint,11,opt,name=object_status,json=objectStatus,proto3,enum=greenfield.storage.ObjectStatus" json:"object_status,omitempty"`
	// redundancy_type define the type of the redundancy which can be multi-replication or EC.
	RedundancyType RedundancyType `protobuf:"varint,12,opt,name=redundancy_type,json=redundancyType,proto3,enum=greenfield.storage.RedundancyType" json:"redundancy_type,omitempty"`
	// source_type define the source of the object.
	SourceType SourceType `protobuf:"varint,13,opt,name=source_type,json=sourceType,proto3,enum=greenfield.storage.SourceType" json:"source_type,omitempty"`
	// checksums define the root hash of the pieces which stored in a SP.
	// add omit tag to omit the field when converting to NFT metadata
	Checksums [][]byte `protobuf:"bytes,14,rep,name=checksums,proto3" json:"checksums,omitempty" traits:"omit"`
}

func (m *ObjectInfo) Reset()         { *m = ObjectInfo{} }
func (m *ObjectInfo) String() string { return proto.CompactTextString(m) }
func (*ObjectInfo) ProtoMessage()    {}
func (*ObjectInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf95fa2efdc74d97, []int{2}
}
func (m *ObjectInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ObjectInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ObjectInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ObjectInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObjectInfo.Merge(m, src)
}
func (m *ObjectInfo) XXX_Size() int {
	return m.Size()
}
func (m *ObjectInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ObjectInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ObjectInfo proto.InternalMessageInfo

func (m *ObjectInfo) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *ObjectInfo) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *ObjectInfo) GetBucketName() string {
	if m != nil {
		return m.BucketName
	}
	return ""
}

func (m *ObjectInfo) GetObjectName() string {
	if m != nil {
		return m.ObjectName
	}
	return ""
}

func (m *ObjectInfo) GetLocalVirtualGroupId() uint32 {
	if m != nil {
		return m.LocalVirtualGroupId
	}
	return 0
}

func (m *ObjectInfo) GetPayloadSize() uint64 {
	if m != nil {
		return m.PayloadSize
	}
	return 0
}

func (m *ObjectInfo) GetVisibility() VisibilityType {
	if m != nil {
		return m.Visibility
	}
	return VISIBILITY_TYPE_UNSPECIFIED
}

func (m *ObjectInfo) GetContentType() string {
	if m != nil {
		return m.ContentType
	}
	return ""
}

func (m *ObjectInfo) GetCreateAt() int64 {
	if m != nil {
		return m.CreateAt
	}
	return 0
}

func (m *ObjectInfo) GetObjectStatus() ObjectStatus {
	if m != nil {
		return m.ObjectStatus
	}
	return OBJECT_STATUS_CREATED
}

func (m *ObjectInfo) GetRedundancyType() RedundancyType {
	if m != nil {
		return m.RedundancyType
	}
	return REDUNDANCY_EC_TYPE
}

func (m *ObjectInfo) GetSourceType() SourceType {
	if m != nil {
		return m.SourceType
	}
	return SOURCE_TYPE_ORIGIN
}

func (m *ObjectInfo) GetChecksums() [][]byte {
	if m != nil {
		return m.Checksums
	}
	return nil
}

type GroupInfo struct {
	// owner is the owner of the group. It can not changed once it created.
	Owner string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	// group_name is the name of group which is unique under an account.
	GroupName string `protobuf:"bytes,2,opt,name=group_name,json=groupName,proto3" json:"group_name,omitempty"`
	// source_type
	SourceType SourceType `protobuf:"varint,3,opt,name=source_type,json=sourceType,proto3,enum=greenfield.storage.SourceType" json:"source_type,omitempty"`
	// id is the unique identifier of group
	Id Uint `protobuf:"bytes,4,opt,name=id,proto3,customtype=Uint" json:"id"`
	// extra is used to store extra info for the group
	Extra string `protobuf:"bytes,5,opt,name=extra,proto3" json:"extra,omitempty"`
}

func (m *GroupInfo) Reset()         { *m = GroupInfo{} }
func (m *GroupInfo) String() string { return proto.CompactTextString(m) }
func (*GroupInfo) ProtoMessage()    {}
func (*GroupInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf95fa2efdc74d97, []int{3}
}
func (m *GroupInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GroupInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GroupInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GroupInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GroupInfo.Merge(m, src)
}
func (m *GroupInfo) XXX_Size() int {
	return m.Size()
}
func (m *GroupInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_GroupInfo.DiscardUnknown(m)
}

var xxx_messageInfo_GroupInfo proto.InternalMessageInfo

func (m *GroupInfo) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *GroupInfo) GetGroupName() string {
	if m != nil {
		return m.GroupName
	}
	return ""
}

func (m *GroupInfo) GetSourceType() SourceType {
	if m != nil {
		return m.SourceType
	}
	return SOURCE_TYPE_ORIGIN
}

func (m *GroupInfo) GetExtra() string {
	if m != nil {
		return m.Extra
	}
	return ""
}

type Trait struct {
	TraitType string `protobuf:"bytes,1,opt,name=trait_type,json=traitType,proto3" json:"trait_type,omitempty"`
	Value     string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *Trait) Reset()         { *m = Trait{} }
func (m *Trait) String() string { return proto.CompactTextString(m) }
func (*Trait) ProtoMessage()    {}
func (*Trait) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf95fa2efdc74d97, []int{4}
}
func (m *Trait) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Trait) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Trait.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Trait) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Trait.Merge(m, src)
}
func (m *Trait) XXX_Size() int {
	return m.Size()
}
func (m *Trait) XXX_DiscardUnknown() {
	xxx_messageInfo_Trait.DiscardUnknown(m)
}

var xxx_messageInfo_Trait proto.InternalMessageInfo

func (m *Trait) GetTraitType() string {
	if m != nil {
		return m.TraitType
	}
	return ""
}

func (m *Trait) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type BucketMetaData struct {
	// description
	Description string `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
	// externalUrl a link to external site to view NFT
	ExternalUrl string `protobuf:"bytes,2,opt,name=external_url,json=externalUrl,proto3" json:"external_url,omitempty"`
	// name of bucket NFT
	BucketName string `protobuf:"bytes,3,opt,name=bucket_name,json=bucketName,proto3" json:"bucket_name,omitempty"`
	// image is the link to image
	Image string `protobuf:"bytes,4,opt,name=image,proto3" json:"image,omitempty"`
	// attributes
	Attributes []Trait `protobuf:"bytes,5,rep,name=attributes,proto3" json:"attributes"`
}

func (m *BucketMetaData) Reset()         { *m = BucketMetaData{} }
func (m *BucketMetaData) String() string { return proto.CompactTextString(m) }
func (*BucketMetaData) ProtoMessage()    {}
func (*BucketMetaData) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf95fa2efdc74d97, []int{5}
}
func (m *BucketMetaData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BucketMetaData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BucketMetaData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BucketMetaData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BucketMetaData.Merge(m, src)
}
func (m *BucketMetaData) XXX_Size() int {
	return m.Size()
}
func (m *BucketMetaData) XXX_DiscardUnknown() {
	xxx_messageInfo_BucketMetaData.DiscardUnknown(m)
}

var xxx_messageInfo_BucketMetaData proto.InternalMessageInfo

func (m *BucketMetaData) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *BucketMetaData) GetExternalUrl() string {
	if m != nil {
		return m.ExternalUrl
	}
	return ""
}

func (m *BucketMetaData) GetBucketName() string {
	if m != nil {
		return m.BucketName
	}
	return ""
}

func (m *BucketMetaData) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *BucketMetaData) GetAttributes() []Trait {
	if m != nil {
		return m.Attributes
	}
	return nil
}

type ObjectMetaData struct {
	// description
	Description string `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
	// externalUrl a link to external site to view NFT
	ExternalUrl string `protobuf:"bytes,2,opt,name=external_url,json=externalUrl,proto3" json:"external_url,omitempty"`
	// name of object NFT
	ObjectName string `protobuf:"bytes,3,opt,name=object_name,json=objectName,proto3" json:"object_name,omitempty"`
	// image is the link to image
	Image string `protobuf:"bytes,4,opt,name=image,proto3" json:"image,omitempty"`
	// attributes
	Attributes []Trait `protobuf:"bytes,5,rep,name=attributes,proto3" json:"attributes"`
}

func (m *ObjectMetaData) Reset()         { *m = ObjectMetaData{} }
func (m *ObjectMetaData) String() string { return proto.CompactTextString(m) }
func (*ObjectMetaData) ProtoMessage()    {}
func (*ObjectMetaData) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf95fa2efdc74d97, []int{6}
}
func (m *ObjectMetaData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ObjectMetaData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ObjectMetaData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ObjectMetaData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObjectMetaData.Merge(m, src)
}
func (m *ObjectMetaData) XXX_Size() int {
	return m.Size()
}
func (m *ObjectMetaData) XXX_DiscardUnknown() {
	xxx_messageInfo_ObjectMetaData.DiscardUnknown(m)
}

var xxx_messageInfo_ObjectMetaData proto.InternalMessageInfo

func (m *ObjectMetaData) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ObjectMetaData) GetExternalUrl() string {
	if m != nil {
		return m.ExternalUrl
	}
	return ""
}

func (m *ObjectMetaData) GetObjectName() string {
	if m != nil {
		return m.ObjectName
	}
	return ""
}

func (m *ObjectMetaData) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *ObjectMetaData) GetAttributes() []Trait {
	if m != nil {
		return m.Attributes
	}
	return nil
}

type GroupMetaData struct {
	// description
	Description string `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
	// externalUrl a link to external site to view NFT
	ExternalUrl string `protobuf:"bytes,2,opt,name=external_url,json=externalUrl,proto3" json:"external_url,omitempty"`
	// name of group NFT
	GroupName string `protobuf:"bytes,3,opt,name=group_name,json=groupName,proto3" json:"group_name,omitempty"`
	// image is the link to image
	Image string `protobuf:"bytes,4,opt,name=image,proto3" json:"image,omitempty"`
	// attributes
	Attributes []Trait `protobuf:"bytes,5,rep,name=attributes,proto3" json:"attributes"`
}

func (m *GroupMetaData) Reset()         { *m = GroupMetaData{} }
func (m *GroupMetaData) String() string { return proto.CompactTextString(m) }
func (*GroupMetaData) ProtoMessage()    {}
func (*GroupMetaData) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf95fa2efdc74d97, []int{7}
}
func (m *GroupMetaData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GroupMetaData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GroupMetaData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GroupMetaData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GroupMetaData.Merge(m, src)
}
func (m *GroupMetaData) XXX_Size() int {
	return m.Size()
}
func (m *GroupMetaData) XXX_DiscardUnknown() {
	xxx_messageInfo_GroupMetaData.DiscardUnknown(m)
}

var xxx_messageInfo_GroupMetaData proto.InternalMessageInfo

func (m *GroupMetaData) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *GroupMetaData) GetExternalUrl() string {
	if m != nil {
		return m.ExternalUrl
	}
	return ""
}

func (m *GroupMetaData) GetGroupName() string {
	if m != nil {
		return m.GroupName
	}
	return ""
}

func (m *GroupMetaData) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *GroupMetaData) GetAttributes() []Trait {
	if m != nil {
		return m.Attributes
	}
	return nil
}

type Ids struct {
	// ids of the objects or buckets
	Id []Uint `protobuf:"bytes,1,rep,name=id,proto3,customtype=Uint" json:"id"`
}

func (m *Ids) Reset()         { *m = Ids{} }
func (m *Ids) String() string { return proto.CompactTextString(m) }
func (*Ids) ProtoMessage()    {}
func (*Ids) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf95fa2efdc74d97, []int{8}
}
func (m *Ids) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Ids) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Ids.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Ids) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ids.Merge(m, src)
}
func (m *Ids) XXX_Size() int {
	return m.Size()
}
func (m *Ids) XXX_DiscardUnknown() {
	xxx_messageInfo_Ids.DiscardUnknown(m)
}

var xxx_messageInfo_Ids proto.InternalMessageInfo

type DeleteInfo struct {
	BucketIds *Ids `protobuf:"bytes,1,opt,name=bucket_ids,json=bucketIds,proto3" json:"bucket_ids,omitempty"`
	ObjectIds *Ids `protobuf:"bytes,2,opt,name=object_ids,json=objectIds,proto3" json:"object_ids,omitempty"`
	GroupIds  *Ids `protobuf:"bytes,3,opt,name=group_ids,json=groupIds,proto3" json:"group_ids,omitempty"`
}

func (m *DeleteInfo) Reset()         { *m = DeleteInfo{} }
func (m *DeleteInfo) String() string { return proto.CompactTextString(m) }
func (*DeleteInfo) ProtoMessage()    {}
func (*DeleteInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf95fa2efdc74d97, []int{9}
}
func (m *DeleteInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteInfo.Merge(m, src)
}
func (m *DeleteInfo) XXX_Size() int {
	return m.Size()
}
func (m *DeleteInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteInfo proto.InternalMessageInfo

func (m *DeleteInfo) GetBucketIds() *Ids {
	if m != nil {
		return m.BucketIds
	}
	return nil
}

func (m *DeleteInfo) GetObjectIds() *Ids {
	if m != nil {
		return m.ObjectIds
	}
	return nil
}

func (m *DeleteInfo) GetGroupIds() *Ids {
	if m != nil {
		return m.GroupIds
	}
	return nil
}

type MigrationBucketInfo struct {
	SrcSpId                       uint32 `protobuf:"varint,1,opt,name=src_sp_id,json=srcSpId,proto3" json:"src_sp_id,omitempty"`
	SrcGlobalVirtualGroupFamilyId uint32 `protobuf:"varint,2,opt,name=src_global_virtual_group_family_id,json=srcGlobalVirtualGroupFamilyId,proto3" json:"src_global_virtual_group_family_id,omitempty"`
	DstSpId                       uint32 `protobuf:"varint,3,opt,name=dst_sp_id,json=dstSpId,proto3" json:"dst_sp_id,omitempty"`
	// id is the unique identifier of bucket
	BucketId Uint `protobuf:"bytes,4,opt,name=bucket_id,json=bucketId,proto3,customtype=Uint" json:"bucket_id"`
}

func (m *MigrationBucketInfo) Reset()         { *m = MigrationBucketInfo{} }
func (m *MigrationBucketInfo) String() string { return proto.CompactTextString(m) }
func (*MigrationBucketInfo) ProtoMessage()    {}
func (*MigrationBucketInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf95fa2efdc74d97, []int{10}
}
func (m *MigrationBucketInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MigrationBucketInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MigrationBucketInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MigrationBucketInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MigrationBucketInfo.Merge(m, src)
}
func (m *MigrationBucketInfo) XXX_Size() int {
	return m.Size()
}
func (m *MigrationBucketInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_MigrationBucketInfo.DiscardUnknown(m)
}

var xxx_messageInfo_MigrationBucketInfo proto.InternalMessageInfo

func (m *MigrationBucketInfo) GetSrcSpId() uint32 {
	if m != nil {
		return m.SrcSpId
	}
	return 0
}

func (m *MigrationBucketInfo) GetSrcGlobalVirtualGroupFamilyId() uint32 {
	if m != nil {
		return m.SrcGlobalVirtualGroupFamilyId
	}
	return 0
}

func (m *MigrationBucketInfo) GetDstSpId() uint32 {
	if m != nil {
		return m.DstSpId
	}
	return 0
}

func init() {
	proto.RegisterType((*BucketInfo)(nil), "greenfield.storage.BucketInfo")
	proto.RegisterType((*InternalBucketInfo)(nil), "greenfield.storage.InternalBucketInfo")
	proto.RegisterType((*ObjectInfo)(nil), "greenfield.storage.ObjectInfo")
	proto.RegisterType((*GroupInfo)(nil), "greenfield.storage.GroupInfo")
	proto.RegisterType((*Trait)(nil), "greenfield.storage.Trait")
	proto.RegisterType((*BucketMetaData)(nil), "greenfield.storage.BucketMetaData")
	proto.RegisterType((*ObjectMetaData)(nil), "greenfield.storage.ObjectMetaData")
	proto.RegisterType((*GroupMetaData)(nil), "greenfield.storage.GroupMetaData")
	proto.RegisterType((*Ids)(nil), "greenfield.storage.Ids")
	proto.RegisterType((*DeleteInfo)(nil), "greenfield.storage.DeleteInfo")
	proto.RegisterType((*MigrationBucketInfo)(nil), "greenfield.storage.MigrationBucketInfo")
}

func init() { proto.RegisterFile("greenfield/storage/types.proto", fileDescriptor_bf95fa2efdc74d97) }

var fileDescriptor_bf95fa2efdc74d97 = []byte{
	// 1180 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x57, 0xdf, 0x6e, 0xdb, 0xb6,
	0x17, 0x8e, 0x22, 0xbb, 0x89, 0x8e, 0xe2, 0xf4, 0x57, 0xd5, 0xf8, 0x55, 0x4d, 0x51, 0xdb, 0x15,
	0xb0, 0xc1, 0xd8, 0x56, 0x1b, 0x4d, 0x87, 0x62, 0x18, 0x0a, 0x14, 0xf5, 0xda, 0x15, 0xc6, 0xd6,
	0x0d, 0x53, 0xda, 0x0e, 0xd8, 0x8d, 0x40, 0x49, 0x8c, 0xc2, 0x55, 0x12, 0x3d, 0x92, 0x4a, 0xe3,
	0x3e, 0xc5, 0x9e, 0x65, 0xe8, 0x0b, 0xec, 0xae, 0x18, 0x36, 0xa0, 0xe8, 0xd5, 0xb0, 0x8b, 0x60,
	0x48, 0xde, 0x60, 0x17, 0xbb, 0x1e, 0x44, 0xd2, 0xa9, 0x62, 0x3b, 0xcd, 0x1f, 0xb4, 0x77, 0xe6,
	0xe1, 0x77, 0xc4, 0x73, 0xbe, 0xf3, 0x9d, 0x43, 0x1a, 0x5a, 0x09, 0xc3, 0x38, 0xdf, 0x24, 0x38,
	0x8d, 0xfb, 0x5c, 0x50, 0x86, 0x12, 0xdc, 0x17, 0xe3, 0x11, 0xe6, 0xbd, 0x11, 0xa3, 0x82, 0x3a,
	0xce, 0x9b, 0xfd, 0x9e, 0xde, 0x5f, 0x6b, 0x45, 0x94, 0x67, 0x94, 0xf7, 0x43, 0xc4, 0x71, 0x7f,
	0xfb, 0x46, 0x88, 0x05, 0xba, 0xd1, 0x8f, 0x28, 0xc9, 0x95, 0xcf, 0xda, 0x65, 0xb5, 0x1f, 0xc8,
	0x55, 0x5f, 0x2d, 0xf4, 0x56, 0x33, 0xa1, 0x09, 0x55, 0xf6, 0xf2, 0x97, 0xb6, 0x5e, 0xab, 0x04,
	0x31, 0x42, 0xe3, 0x0c, 0xe7, 0xa2, 0x4f, 0x0b, 0x11, 0x6c, 0xa6, 0xf4, 0x99, 0x86, 0x7c, 0x38,
	0x07, 0xc2, 0x05, 0xc3, 0x28, 0x0b, 0x18, 0x8e, 0x28, 0x8b, 0x35, 0xae, 0x3d, 0x27, 0x9f, 0x88,
	0x66, 0x19, 0xd5, 0xc1, 0x79, 0xbf, 0xd7, 0x00, 0x06, 0x45, 0xf4, 0x14, 0x8b, 0x61, 0xbe, 0x49,
	0x9d, 0x1e, 0xd4, 0xe9, 0xb3, 0x1c, 0x33, 0xd7, 0xe8, 0x18, 0x5d, 0x6b, 0xe0, 0xbe, 0x7e, 0x71,
	0xbd, 0xa9, 0x23, 0xbe, 0x1b, 0xc7, 0x0c, 0x73, 0xbe, 0x21, 0x18, 0xc9, 0x13, 0x5f, 0xc1, 0x9c,
	0x36, 0xd8, 0xa1, 0xf4, 0x0e, 0x72, 0x94, 0x61, 0x77, 0xb1, 0xf4, 0xf2, 0x41, 0x99, 0xbe, 0x41,
	0x19, 0x76, 0x06, 0x00, 0xdb, 0x84, 0x93, 0x90, 0xa4, 0x44, 0x8c, 0x5d, 0xb3, 0x63, 0x74, 0x57,
	0xd7, 0xbd, 0xde, 0x2c, 0x8b, 0xbd, 0x27, 0x07, 0xa8, 0x47, 0xe3, 0x11, 0xf6, 0x2b, 0x5e, 0xce,
	0xc7, 0xb0, 0x48, 0x62, 0xb7, 0x26, 0x23, 0xba, 0xf2, 0x72, 0xb7, 0xbd, 0xf0, 0xd7, 0x6e, 0xbb,
	0xf6, 0x98, 0xe4, 0xe2, 0xf5, 0x8b, 0xeb, 0xb6, 0x8e, 0xae, 0x5c, 0xfa, 0x8b, 0x24, 0x76, 0xee,
	0x80, 0xcd, 0x69, 0xc1, 0x22, 0x1c, 0x94, 0x75, 0x73, 0xeb, 0xf2, 0xc4, 0xd6, 0xbc, 0x13, 0x37,
	0x24, 0x4c, 0x9d, 0xc6, 0x0f, 0x7e, 0x3b, 0x57, 0xc0, 0x8a, 0x18, 0x46, 0x02, 0x07, 0x48, 0xb8,
	0xe7, 0x3a, 0x46, 0xd7, 0xf4, 0x97, 0x95, 0xe1, 0xae, 0x70, 0xee, 0xc2, 0x79, 0x4d, 0x77, 0x80,
	0x14, 0x1f, 0xee, 0xd2, 0x31, 0x4c, 0xad, 0x6a, 0x07, 0x6d, 0x75, 0x3c, 0x68, 0x8c, 0x18, 0xc9,
	0x10, 0x1b, 0x07, 0x7c, 0x14, 0x90, 0xd8, 0x5d, 0xee, 0x18, 0xdd, 0x86, 0x6f, 0x6b, 0xe3, 0xc6,
	0x68, 0x18, 0x3b, 0x03, 0x68, 0x25, 0x29, 0x0d, 0x51, 0x1a, 0x6c, 0x13, 0x26, 0x0a, 0x94, 0x06,
	0x09, 0xa3, 0xc5, 0x28, 0xd8, 0x44, 0x19, 0x49, 0xc7, 0xa5, 0x93, 0x25, 0x9d, 0xd6, 0x14, 0xea,
	0x89, 0x02, 0x3d, 0x28, 0x31, 0x5f, 0x4a, 0xc8, 0x30, 0x76, 0x3e, 0x01, 0x27, 0xda, 0x42, 0x2c,
	0xc1, 0x71, 0xc0, 0x30, 0x8a, 0x83, 0x9f, 0x0a, 0x2a, 0x90, 0x0b, 0x1d, 0xa3, 0x5b, 0xf3, 0xff,
	0xa7, 0x77, 0x7c, 0x8c, 0xe2, 0xef, 0x4a, 0xbb, 0x73, 0x1f, 0x1a, 0xba, 0x90, 0x5c, 0x20, 0x51,
	0x70, 0xd7, 0x96, 0xc4, 0x75, 0xe6, 0x11, 0xa7, 0xf4, 0xb2, 0x21, 0x71, 0xfe, 0x4a, 0x58, 0x59,
	0x79, 0xff, 0x1a, 0xe0, 0x0c, 0x73, 0x81, 0x59, 0x8e, 0xd2, 0x8a, 0xac, 0xae, 0x02, 0x8c, 0x18,
	0x29, 0x6b, 0x42, 0x32, 0x2c, 0xb5, 0x65, 0xfa, 0x96, 0xb4, 0x3c, 0x22, 0x19, 0x76, 0x3e, 0x82,
	0x0b, 0x82, 0x0a, 0x94, 0x06, 0x2a, 0xac, 0x80, 0x93, 0xe7, 0x4a, 0x4b, 0x35, 0xff, 0xbc, 0xdc,
	0xf8, 0x42, 0xda, 0x37, 0xc8, 0x73, 0xec, 0x7c, 0x0f, 0xcd, 0x94, 0x46, 0xd3, 0xcc, 0x70, 0xd7,
	0xec, 0x98, 0x5d, 0x7b, 0xfd, 0x83, 0x79, 0xf1, 0x7e, 0x5d, 0xe2, 0xab, 0x1c, 0xf9, 0x4e, 0x3a,
	0x6d, 0xe2, 0xce, 0x6d, 0xb8, 0x92, 0xe3, 0x1d, 0x11, 0xcc, 0xf9, 0x7a, 0xa0, 0xe5, 0xd7, 0xf0,
	0x2f, 0x95, 0x90, 0x99, 0xef, 0x0d, 0x63, 0xef, 0xd7, 0x3a, 0xc0, 0xb7, 0xe1, 0x8f, 0x38, 0x3a,
	0x5b, 0x1f, 0xad, 0xc3, 0x92, 0xd4, 0x18, 0x65, 0xaa, 0x87, 0xde, 0xe2, 0x31, 0x01, 0x4e, 0xf7,
	0x9e, 0x39, 0xd3, 0x7b, 0x6d, 0xb0, 0xa9, 0x0c, 0x49, 0x01, 0x6a, 0x0a, 0xa0, 0x4c, 0x12, 0xa0,
	0x1a, 0xab, 0x7e, 0xb2, 0xc6, 0xba, 0x09, 0xff, 0x3f, 0x82, 0x9a, 0x73, 0x92, 0x9a, 0x8b, 0xe9,
	0x2c, 0x2d, 0xce, 0x35, 0x58, 0x19, 0xa1, 0x71, 0x4a, 0x51, 0xac, 0x8a, 0xba, 0x24, 0x8b, 0x6a,
	0x6b, 0x9b, 0x2c, 0xe8, 0xe1, 0x09, 0xb1, 0x7c, 0xa6, 0x09, 0x71, 0x0d, 0x56, 0x22, 0x9a, 0x8b,
	0xb2, 0x2d, 0x65, 0xd7, 0x5b, 0x32, 0x55, 0x5b, 0xdb, 0x66, 0xdb, 0x1a, 0xa6, 0xda, 0xfa, 0x3e,
	0x34, 0x34, 0x53, 0xc7, 0xab, 0x5f, 0x55, 0x79, 0xa2, 0x7e, 0x5a, 0x59, 0x39, 0x5f, 0xc1, 0x79,
	0x86, 0xe3, 0x22, 0x8f, 0x51, 0x1e, 0x8d, 0x55, 0x24, 0x2b, 0x47, 0xe7, 0xe3, 0x1f, 0x40, 0x65,
	0x3e, 0xab, 0xec, 0xd0, 0x7a, 0x7a, 0x90, 0x35, 0x4e, 0x3d, 0xc8, 0xfa, 0x60, 0x45, 0x5b, 0x38,
	0x7a, 0xca, 0x8b, 0x8c, 0xbb, 0xab, 0x1d, 0xb3, 0xbb, 0x32, 0xb8, 0xf0, 0xcf, 0x6e, 0xbb, 0x21,
	0x18, 0x22, 0x82, 0x7f, 0xee, 0xd1, 0x8c, 0x08, 0xcf, 0x7f, 0x83, 0xf1, 0x76, 0x0d, 0xb0, 0x54,
	0xe1, 0xce, 0x22, 0xe1, 0xab, 0x00, 0x4a, 0x11, 0x95, 0x9b, 0xc0, 0x92, 0x16, 0xa9, 0xb5, 0xa9,
	0x74, 0xcc, 0x53, 0xa7, 0x73, 0xaa, 0x5b, 0xa0, 0x09, 0x75, 0xbc, 0x23, 0x18, 0x52, 0xe2, 0xf6,
	0xd5, 0xc2, 0xbb, 0x0d, 0xf5, 0x47, 0x65, 0xf2, 0x65, 0xac, 0x92, 0x05, 0x15, 0x8b, 0xa1, 0x62,
	0x95, 0x16, 0x79, 0x54, 0x13, 0xea, 0xdb, 0x28, 0x2d, 0x26, 0x59, 0xa8, 0x85, 0xf7, 0x87, 0x01,
	0xab, 0x6a, 0xa6, 0x3d, 0xc4, 0x02, 0xdd, 0x43, 0x02, 0x39, 0x1d, 0xb0, 0x63, 0xcc, 0x23, 0x46,
	0x46, 0x82, 0xd0, 0x5c, 0x7f, 0xa8, 0x6a, 0x2a, 0x95, 0x89, 0x77, 0xd4, 0x3c, 0x0c, 0x0a, 0x96,
	0xea, 0x2f, 0xda, 0x13, 0xdb, 0x63, 0x96, 0x1e, 0xdf, 0xc7, 0x4d, 0xa8, 0x93, 0x0c, 0x25, 0x93,
	0x0e, 0x56, 0x0b, 0xe7, 0x0e, 0x00, 0x12, 0x82, 0x91, 0xb0, 0x10, 0x98, 0xbb, 0x75, 0x39, 0xfe,
	0x2e, 0xcf, 0xe3, 0x53, 0xa6, 0x3c, 0xa8, 0x95, 0x94, 0xf9, 0x15, 0x17, 0x99, 0x8f, 0x12, 0xf3,
	0x3b, 0xcf, 0xa7, 0x3a, 0x76, 0xcc, 0x99, 0xb1, 0xf3, 0x9e, 0xf2, 0xf9, 0xcd, 0x80, 0x86, 0x94,
	0xef, 0xbb, 0x4d, 0xe7, 0xb0, 0xae, 0xcd, 0x69, 0x5d, 0xbf, 0xa7, 0x64, 0xd6, 0xc1, 0x1c, 0xc6,
	0x5c, 0x8b, 0xde, 0xe8, 0x98, 0x27, 0x10, 0xbd, 0xf7, 0x8b, 0x01, 0x70, 0x0f, 0xa7, 0x58, 0x60,
	0xd9, 0xc0, 0xb7, 0x40, 0x8b, 0x28, 0x20, 0x31, 0x97, 0xc9, 0xdb, 0xeb, 0x97, 0xe6, 0xc5, 0x30,
	0x8c, 0xb9, 0x6f, 0x29, 0x68, 0x79, 0xe6, 0x2d, 0xd0, 0xc5, 0x92, 0x7e, 0x8b, 0xc7, 0xf8, 0x29,
	0x68, 0xe9, 0xf7, 0x29, 0x58, 0x93, 0x2b, 0x81, 0x4b, 0x9e, 0xde, 0xe2, 0xb6, 0x9c, 0xa8, 0x0b,
	0x82, 0x7b, 0xaf, 0x0d, 0xb8, 0xf8, 0x90, 0x24, 0x0c, 0x95, 0xf5, 0xa8, 0x3c, 0x19, 0xd6, 0xc0,
	0xe2, 0x2c, 0xd2, 0x4f, 0x24, 0x43, 0xde, 0x30, 0x4b, 0x9c, 0x45, 0xf2, 0x79, 0x34, 0x04, 0xaf,
	0xdc, 0x3b, 0xe6, 0x89, 0xb4, 0x28, 0x9d, 0xae, 0x72, 0x16, 0x3d, 0x38, 0xfa, 0x95, 0xb4, 0x06,
	0x56, 0xcc, 0x85, 0x3e, 0xc6, 0x54, 0xc7, 0xc4, 0x5c, 0xc8, 0x63, 0x3e, 0x03, 0xeb, 0x80, 0xc0,
	0x93, 0x0c, 0x9e, 0xe5, 0x09, 0x87, 0x83, 0xe1, 0xcb, 0xbd, 0x96, 0xf1, 0x6a, 0xaf, 0x65, 0xfc,
	0xbd, 0xd7, 0x32, 0x7e, 0xde, 0x6f, 0x2d, 0xbc, 0xda, 0x6f, 0x2d, 0xfc, 0xb9, 0xdf, 0x5a, 0xf8,
	0xa1, 0x9f, 0x10, 0xb1, 0x55, 0x84, 0xbd, 0x88, 0x66, 0xfd, 0x30, 0x0f, 0xaf, 0x47, 0x5b, 0x88,
	0xe4, 0xfd, 0xca, 0x2b, 0x7d, 0xe7, 0xf0, 0xff, 0x8e, 0xf0, 0x9c, 0x7c, 0xa7, 0xdf, 0xfc, 0x2f,
	0x00, 0x00, 0xff, 0xff, 0xe9, 0x7b, 0x5b, 0x1a, 0x9a, 0x0c, 0x00, 0x00,
}

func (m *BucketInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BucketInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BucketInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BucketStatus != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.BucketStatus))
		i--
		dAtA[i] = 0x58
	}
	if m.ChargedReadQuota != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ChargedReadQuota))
		i--
		dAtA[i] = 0x50
	}
	if m.GlobalVirtualGroupFamilyId != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.GlobalVirtualGroupFamilyId))
		i--
		dAtA[i] = 0x48
	}
	if m.PrimarySpId != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.PrimarySpId))
		i--
		dAtA[i] = 0x40
	}
	if len(m.PaymentAddress) > 0 {
		i -= len(m.PaymentAddress)
		copy(dAtA[i:], m.PaymentAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PaymentAddress)))
		i--
		dAtA[i] = 0x3a
	}
	if m.CreateAt != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CreateAt))
		i--
		dAtA[i] = 0x30
	}
	if m.SourceType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SourceType))
		i--
		dAtA[i] = 0x28
	}
	{
		size := m.Id.Size()
		i -= size
		if _, err := m.Id.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.Visibility != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Visibility))
		i--
		dAtA[i] = 0x18
	}
	if len(m.BucketName) > 0 {
		i -= len(m.BucketName)
		copy(dAtA[i:], m.BucketName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BucketName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InternalBucketInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InternalBucketInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InternalBucketInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NextLocalVirtualGroupId != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.NextLocalVirtualGroupId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.LocalVirtualGroups) > 0 {
		for iNdEx := len(m.LocalVirtualGroups) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LocalVirtualGroups[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.TotalChargeSize != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.TotalChargeSize))
		i--
		dAtA[i] = 0x10
	}
	if m.PriceTime != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.PriceTime))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ObjectInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ObjectInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Checksums) > 0 {
		for iNdEx := len(m.Checksums) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Checksums[iNdEx])
			copy(dAtA[i:], m.Checksums[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Checksums[iNdEx])))
			i--
			dAtA[i] = 0x72
		}
	}
	if m.SourceType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SourceType))
		i--
		dAtA[i] = 0x68
	}
	if m.RedundancyType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.RedundancyType))
		i--
		dAtA[i] = 0x60
	}
	if m.ObjectStatus != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ObjectStatus))
		i--
		dAtA[i] = 0x58
	}
	if m.CreateAt != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CreateAt))
		i--
		dAtA[i] = 0x50
	}
	if len(m.ContentType) > 0 {
		i -= len(m.ContentType)
		copy(dAtA[i:], m.ContentType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ContentType)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Visibility != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Visibility))
		i--
		dAtA[i] = 0x40
	}
	if m.PayloadSize != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.PayloadSize))
		i--
		dAtA[i] = 0x38
	}
	if m.LocalVirtualGroupId != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.LocalVirtualGroupId))
		i--
		dAtA[i] = 0x30
	}
	{
		size := m.Id.Size()
		i -= size
		if _, err := m.Id.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.ObjectName) > 0 {
		i -= len(m.ObjectName)
		copy(dAtA[i:], m.ObjectName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ObjectName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.BucketName) > 0 {
		i -= len(m.BucketName)
		copy(dAtA[i:], m.BucketName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BucketName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GroupInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GroupInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Extra) > 0 {
		i -= len(m.Extra)
		copy(dAtA[i:], m.Extra)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Extra)))
		i--
		dAtA[i] = 0x2a
	}
	{
		size := m.Id.Size()
		i -= size
		if _, err := m.Id.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.SourceType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SourceType))
		i--
		dAtA[i] = 0x18
	}
	if len(m.GroupName) > 0 {
		i -= len(m.GroupName)
		copy(dAtA[i:], m.GroupName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.GroupName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Trait) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Trait) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Trait) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TraitType) > 0 {
		i -= len(m.TraitType)
		copy(dAtA[i:], m.TraitType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TraitType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BucketMetaData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BucketMetaData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BucketMetaData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Attributes) > 0 {
		for iNdEx := len(m.Attributes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Attributes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Image) > 0 {
		i -= len(m.Image)
		copy(dAtA[i:], m.Image)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Image)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.BucketName) > 0 {
		i -= len(m.BucketName)
		copy(dAtA[i:], m.BucketName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BucketName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ExternalUrl) > 0 {
		i -= len(m.ExternalUrl)
		copy(dAtA[i:], m.ExternalUrl)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ExternalUrl)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ObjectMetaData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectMetaData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ObjectMetaData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Attributes) > 0 {
		for iNdEx := len(m.Attributes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Attributes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Image) > 0 {
		i -= len(m.Image)
		copy(dAtA[i:], m.Image)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Image)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ObjectName) > 0 {
		i -= len(m.ObjectName)
		copy(dAtA[i:], m.ObjectName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ObjectName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ExternalUrl) > 0 {
		i -= len(m.ExternalUrl)
		copy(dAtA[i:], m.ExternalUrl)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ExternalUrl)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GroupMetaData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupMetaData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GroupMetaData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Attributes) > 0 {
		for iNdEx := len(m.Attributes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Attributes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Image) > 0 {
		i -= len(m.Image)
		copy(dAtA[i:], m.Image)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Image)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.GroupName) > 0 {
		i -= len(m.GroupName)
		copy(dAtA[i:], m.GroupName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.GroupName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ExternalUrl) > 0 {
		i -= len(m.ExternalUrl)
		copy(dAtA[i:], m.ExternalUrl)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ExternalUrl)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Ids) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ids) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Ids) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		for iNdEx := len(m.Id) - 1; iNdEx >= 0; iNdEx-- {
			{
				size := m.Id[iNdEx].Size()
				i -= size
				if _, err := m.Id[iNdEx].MarshalTo(dAtA[i:]); err != nil {
					return 0, err
				}
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DeleteInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GroupIds != nil {
		{
			size, err := m.GroupIds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ObjectIds != nil {
		{
			size, err := m.ObjectIds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.BucketIds != nil {
		{
			size, err := m.BucketIds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MigrationBucketInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MigrationBucketInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MigrationBucketInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.BucketId.Size()
		i -= size
		if _, err := m.BucketId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.DstSpId != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DstSpId))
		i--
		dAtA[i] = 0x18
	}
	if m.SrcGlobalVirtualGroupFamilyId != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SrcGlobalVirtualGroupFamilyId))
		i--
		dAtA[i] = 0x10
	}
	if m.SrcSpId != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SrcSpId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *BucketInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.BucketName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Visibility != 0 {
		n += 1 + sovTypes(uint64(m.Visibility))
	}
	l = m.Id.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.SourceType != 0 {
		n += 1 + sovTypes(uint64(m.SourceType))
	}
	if m.CreateAt != 0 {
		n += 1 + sovTypes(uint64(m.CreateAt))
	}
	l = len(m.PaymentAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PrimarySpId != 0 {
		n += 1 + sovTypes(uint64(m.PrimarySpId))
	}
	if m.GlobalVirtualGroupFamilyId != 0 {
		n += 1 + sovTypes(uint64(m.GlobalVirtualGroupFamilyId))
	}
	if m.ChargedReadQuota != 0 {
		n += 1 + sovTypes(uint64(m.ChargedReadQuota))
	}
	if m.BucketStatus != 0 {
		n += 1 + sovTypes(uint64(m.BucketStatus))
	}
	return n
}

func (m *InternalBucketInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PriceTime != 0 {
		n += 1 + sovTypes(uint64(m.PriceTime))
	}
	if m.TotalChargeSize != 0 {
		n += 1 + sovTypes(uint64(m.TotalChargeSize))
	}
	if len(m.LocalVirtualGroups) > 0 {
		for _, e := range m.LocalVirtualGroups {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.NextLocalVirtualGroupId != 0 {
		n += 1 + sovTypes(uint64(m.NextLocalVirtualGroupId))
	}
	return n
}

func (m *ObjectInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.BucketName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ObjectName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Id.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.LocalVirtualGroupId != 0 {
		n += 1 + sovTypes(uint64(m.LocalVirtualGroupId))
	}
	if m.PayloadSize != 0 {
		n += 1 + sovTypes(uint64(m.PayloadSize))
	}
	if m.Visibility != 0 {
		n += 1 + sovTypes(uint64(m.Visibility))
	}
	l = len(m.ContentType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CreateAt != 0 {
		n += 1 + sovTypes(uint64(m.CreateAt))
	}
	if m.ObjectStatus != 0 {
		n += 1 + sovTypes(uint64(m.ObjectStatus))
	}
	if m.RedundancyType != 0 {
		n += 1 + sovTypes(uint64(m.RedundancyType))
	}
	if m.SourceType != 0 {
		n += 1 + sovTypes(uint64(m.SourceType))
	}
	if len(m.Checksums) > 0 {
		for _, b := range m.Checksums {
			l = len(b)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *GroupInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.GroupName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.SourceType != 0 {
		n += 1 + sovTypes(uint64(m.SourceType))
	}
	l = m.Id.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = len(m.Extra)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Trait) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TraitType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *BucketMetaData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ExternalUrl)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.BucketName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Attributes) > 0 {
		for _, e := range m.Attributes {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *ObjectMetaData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ExternalUrl)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ObjectName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Attributes) > 0 {
		for _, e := range m.Attributes {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *GroupMetaData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ExternalUrl)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.GroupName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Attributes) > 0 {
		for _, e := range m.Attributes {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *Ids) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Id) > 0 {
		for _, e := range m.Id {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *DeleteInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BucketIds != nil {
		l = m.BucketIds.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ObjectIds != nil {
		l = m.ObjectIds.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.GroupIds != nil {
		l = m.GroupIds.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *MigrationBucketInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SrcSpId != 0 {
		n += 1 + sovTypes(uint64(m.SrcSpId))
	}
	if m.SrcGlobalVirtualGroupFamilyId != 0 {
		n += 1 + sovTypes(uint64(m.SrcGlobalVirtualGroupFamilyId))
	}
	if m.DstSpId != 0 {
		n += 1 + sovTypes(uint64(m.DstSpId))
	}
	l = m.BucketId.Size()
	n += 1 + l + sovTypes(uint64(l))
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *BucketInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BucketInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BucketInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BucketName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BucketName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Visibility", wireType)
			}
			m.Visibility = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Visibility |= VisibilityType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceType", wireType)
			}
			m.SourceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceType |= SourceType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
			}
			m.CreateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PaymentAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimarySpId", wireType)
			}
			m.PrimarySpId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrimarySpId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalVirtualGroupFamilyId", wireType)
			}
			m.GlobalVirtualGroupFamilyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GlobalVirtualGroupFamilyId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChargedReadQuota", wireType)
			}
			m.ChargedReadQuota = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChargedReadQuota |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BucketStatus", wireType)
			}
			m.BucketStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BucketStatus |= BucketStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InternalBucketInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InternalBucketInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InternalBucketInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceTime", wireType)
			}
			m.PriceTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PriceTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalChargeSize", wireType)
			}
			m.TotalChargeSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalChargeSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalVirtualGroups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalVirtualGroups = append(m.LocalVirtualGroups, &LocalVirtualGroup{})
			if err := m.LocalVirtualGroups[len(m.LocalVirtualGroups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextLocalVirtualGroupId", wireType)
			}
			m.NextLocalVirtualGroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextLocalVirtualGroupId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BucketName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BucketName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalVirtualGroupId", wireType)
			}
			m.LocalVirtualGroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocalVirtualGroupId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadSize", wireType)
			}
			m.PayloadSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PayloadSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Visibility", wireType)
			}
			m.Visibility = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Visibility |= VisibilityType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
			}
			m.CreateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectStatus", wireType)
			}
			m.ObjectStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjectStatus |= ObjectStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedundancyType", wireType)
			}
			m.RedundancyType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RedundancyType |= RedundancyType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceType", wireType)
			}
			m.SourceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceType |= SourceType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checksums", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Checksums = append(m.Checksums, make([]byte, postIndex-iNdEx))
			copy(m.Checksums[len(m.Checksums)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceType", wireType)
			}
			m.SourceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceType |= SourceType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extra", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Extra = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Trait) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Trait: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Trait: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraitType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TraitType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BucketMetaData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BucketMetaData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BucketMetaData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BucketName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BucketName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attributes = append(m.Attributes, Trait{})
			if err := m.Attributes[len(m.Attributes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectMetaData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectMetaData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectMetaData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attributes = append(m.Attributes, Trait{})
			if err := m.Attributes[len(m.Attributes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupMetaData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupMetaData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupMetaData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attributes = append(m.Attributes, Trait{})
			if err := m.Attributes[len(m.Attributes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ids) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ids: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ids: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v Uint
			m.Id = append(m.Id, v)
			if err := m.Id[len(m.Id)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BucketIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BucketIds == nil {
				m.BucketIds = &Ids{}
			}
			if err := m.BucketIds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjectIds == nil {
				m.ObjectIds = &Ids{}
			}
			if err := m.ObjectIds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GroupIds == nil {
				m.GroupIds = &Ids{}
			}
			if err := m.GroupIds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MigrationBucketInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MigrationBucketInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MigrationBucketInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcSpId", wireType)
			}
			m.SrcSpId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcSpId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcGlobalVirtualGroupFamilyId", wireType)
			}
			m.SrcGlobalVirtualGroupFamilyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcGlobalVirtualGroupFamilyId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstSpId", wireType)
			}
			m.DstSpId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstSpId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BucketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BucketId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
