// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: greenfield/storage/types.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ReadQuota int32

const (
	READ_QUOTA_FREE ReadQuota = 0
)

var ReadQuota_name = map[int32]string{
	0: "READ_QUOTA_FREE",
}

var ReadQuota_value = map[string]int32{
	"READ_QUOTA_FREE": 0,
}

func (x ReadQuota) String() string {
	return proto.EnumName(ReadQuota_name, int32(x))
}

func (ReadQuota) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bf95fa2efdc74d97, []int{0}
}

type RedundancyType int32

const (
	REDUNDANCY_REPLICA_TYPE RedundancyType = 0
	REDUNDANCY_EC_TYPE      RedundancyType = 1
	REDUNDANCY_INLINE_TYPE  RedundancyType = 2
)

var RedundancyType_name = map[int32]string{
	0: "REDUNDANCY_REPLICA_TYPE",
	1: "REDUNDANCY_EC_TYPE",
	2: "REDUNDANCY_INLINE_TYPE",
}

var RedundancyType_value = map[string]int32{
	"REDUNDANCY_REPLICA_TYPE": 0,
	"REDUNDANCY_EC_TYPE":      1,
	"REDUNDANCY_INLINE_TYPE":  2,
}

func (x RedundancyType) String() string {
	return proto.EnumName(RedundancyType_name, int32(x))
}

func (RedundancyType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bf95fa2efdc74d97, []int{1}
}

type ObjectStatus int32

const (
	OBJECT_STATUS_INIT       ObjectStatus = 0
	OBJECT_STATUS_IN_SERVICE ObjectStatus = 1
)

var ObjectStatus_name = map[int32]string{
	0: "OBJECT_STATUS_INIT",
	1: "OBJECT_STATUS_IN_SERVICE",
}

var ObjectStatus_value = map[string]int32{
	"OBJECT_STATUS_INIT":       0,
	"OBJECT_STATUS_IN_SERVICE": 1,
}

func (x ObjectStatus) String() string {
	return proto.EnumName(ObjectStatus_name, int32(x))
}

func (ObjectStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bf95fa2efdc74d97, []int{2}
}

type BucketInfo struct {
	// owner is the account address of bucket creator, it is also the bucket owner.
	Owner string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	// bucket_name is a globally unique name of bucket
	BucketName string `protobuf:"bytes,2,opt,name=bucket_name,json=bucketName,proto3" json:"bucket_name,omitempty"`
	// is_public define the highest permissions for bucket. When the bucket is public, everyone can get the object in it.
	IsPublic bool `protobuf:"varint,3,opt,name=is_public,json=isPublic,proto3" json:"is_public,omitempty"`
	// id is the unique identification for greenfield resource
	Id uint64 `protobuf:"varint,4,opt,name=id,proto3" json:"id,omitempty"`
	// create_at define the block number when the bucket created.
	CreateAt int64 `protobuf:"varint,5,opt,name=create_at,json=createAt,proto3" json:"create_at,omitempty"`
	// payment_address is the address of the payment account
	PaymentAddress string `protobuf:"bytes,6,opt,name=payment_address,json=paymentAddress,proto3" json:"payment_address,omitempty"`
	// primary_sp_address is the address of the primary sp. Objects belongs to this bucket will never
	// leave this SP, unless you explicitly shift them to another SP.
	PrimarySpAddress string `protobuf:"bytes,7,opt,name=primary_sp_address,json=primarySpAddress,proto3" json:"primary_sp_address,omitempty"`
	// read_quota defines the traffic quota for read
	ReadQuota ReadQuota `protobuf:"varint,8,opt,name=read_quota,json=readQuota,proto3,enum=bnbchain.greenfield.storage.ReadQuota" json:"read_quota,omitempty"`
}

func (m *BucketInfo) Reset()         { *m = BucketInfo{} }
func (m *BucketInfo) String() string { return proto.CompactTextString(m) }
func (*BucketInfo) ProtoMessage()    {}
func (*BucketInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf95fa2efdc74d97, []int{0}
}
func (m *BucketInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BucketInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BucketInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BucketInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BucketInfo.Merge(m, src)
}
func (m *BucketInfo) XXX_Size() int {
	return m.Size()
}
func (m *BucketInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_BucketInfo.DiscardUnknown(m)
}

var xxx_messageInfo_BucketInfo proto.InternalMessageInfo

func (m *BucketInfo) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *BucketInfo) GetBucketName() string {
	if m != nil {
		return m.BucketName
	}
	return ""
}

func (m *BucketInfo) GetIsPublic() bool {
	if m != nil {
		return m.IsPublic
	}
	return false
}

func (m *BucketInfo) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *BucketInfo) GetCreateAt() int64 {
	if m != nil {
		return m.CreateAt
	}
	return 0
}

func (m *BucketInfo) GetPaymentAddress() string {
	if m != nil {
		return m.PaymentAddress
	}
	return ""
}

func (m *BucketInfo) GetPrimarySpAddress() string {
	if m != nil {
		return m.PrimarySpAddress
	}
	return ""
}

func (m *BucketInfo) GetReadQuota() ReadQuota {
	if m != nil {
		return m.ReadQuota
	}
	return READ_QUOTA_FREE
}

type ObjectInfo struct {
	Owner string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	// bucket_name is the name of the bucket
	BucketName string `protobuf:"bytes,2,opt,name=bucket_name,json=bucketName,proto3" json:"bucket_name,omitempty"`
	// object_name is the name of object
	ObjectName string `protobuf:"bytes,3,opt,name=object_name,json=objectName,proto3" json:"object_name,omitempty"`
	// id is the unique identifier of an object
	Id uint64 `protobuf:"varint,4,opt,name=id,proto3" json:"id,omitempty"`
	// payloadSize is the total size of the object payload
	PayloadSize uint64 `protobuf:"varint,5,opt,name=payload_size,json=payloadSize,proto3" json:"payload_size,omitempty"`
	// is_public define the highest permissions for object. When the object is public, everyone can access it.
	IsPublic bool `protobuf:"varint,6,opt,name=is_public,json=isPublic,proto3" json:"is_public,omitempty"`
	// content_type define the format of the object which should be a standard MIME type.
	ContentType string `protobuf:"bytes,7,opt,name=content_type,json=contentType,proto3" json:"content_type,omitempty"`
	// create_at define the block number when the object created
	CreateAt int64 `protobuf:"varint,8,opt,name=create_at,json=createAt,proto3" json:"create_at,omitempty"`
	// object_status define the upload status of the object.
	ObjectStatus ObjectStatus `protobuf:"varint,9,opt,name=object_status,json=objectStatus,proto3,enum=bnbchain.greenfield.storage.ObjectStatus" json:"object_status,omitempty"`
	// redundancy_type define the type of the redundancy which can be multi-replication or EC.
	RedundancyType RedundancyType `protobuf:"varint,10,opt,name=redundancy_type,json=redundancyType,proto3,enum=bnbchain.greenfield.storage.RedundancyType" json:"redundancy_type,omitempty"`
	// source_type define the source of the object.
	SourceType SourceType `protobuf:"varint,11,opt,name=source_type,json=sourceType,proto3,enum=bnbchain.greenfield.storage.SourceType" json:"source_type,omitempty"`
	// checksums define the root hash of the pieces which stored in a SP.
	Checksums [][]byte `protobuf:"bytes,12,rep,name=checksums,proto3" json:"checksums,omitempty"`
	// secondary_sp_addresses define the addresses of secondary_sps
	SecondarySpAddresses []string `protobuf:"bytes,13,rep,name=secondary_sp_addresses,json=secondarySpAddresses,proto3" json:"secondary_sp_addresses,omitempty"`
}

func (m *ObjectInfo) Reset()         { *m = ObjectInfo{} }
func (m *ObjectInfo) String() string { return proto.CompactTextString(m) }
func (*ObjectInfo) ProtoMessage()    {}
func (*ObjectInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf95fa2efdc74d97, []int{1}
}
func (m *ObjectInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ObjectInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ObjectInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ObjectInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObjectInfo.Merge(m, src)
}
func (m *ObjectInfo) XXX_Size() int {
	return m.Size()
}
func (m *ObjectInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ObjectInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ObjectInfo proto.InternalMessageInfo

func (m *ObjectInfo) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *ObjectInfo) GetBucketName() string {
	if m != nil {
		return m.BucketName
	}
	return ""
}

func (m *ObjectInfo) GetObjectName() string {
	if m != nil {
		return m.ObjectName
	}
	return ""
}

func (m *ObjectInfo) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ObjectInfo) GetPayloadSize() uint64 {
	if m != nil {
		return m.PayloadSize
	}
	return 0
}

func (m *ObjectInfo) GetIsPublic() bool {
	if m != nil {
		return m.IsPublic
	}
	return false
}

func (m *ObjectInfo) GetContentType() string {
	if m != nil {
		return m.ContentType
	}
	return ""
}

func (m *ObjectInfo) GetCreateAt() int64 {
	if m != nil {
		return m.CreateAt
	}
	return 0
}

func (m *ObjectInfo) GetObjectStatus() ObjectStatus {
	if m != nil {
		return m.ObjectStatus
	}
	return OBJECT_STATUS_INIT
}

func (m *ObjectInfo) GetRedundancyType() RedundancyType {
	if m != nil {
		return m.RedundancyType
	}
	return REDUNDANCY_REPLICA_TYPE
}

func (m *ObjectInfo) GetSourceType() SourceType {
	if m != nil {
		return m.SourceType
	}
	return SOURCE_TYPE_ORIGIN
}

func (m *ObjectInfo) GetChecksums() [][]byte {
	if m != nil {
		return m.Checksums
	}
	return nil
}

func (m *ObjectInfo) GetSecondarySpAddresses() []string {
	if m != nil {
		return m.SecondarySpAddresses
	}
	return nil
}

type GroupInfo struct {
	Owner     string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	GroupName string `protobuf:"bytes,2,opt,name=group_name,json=groupName,proto3" json:"group_name,omitempty"`
	Id        uint64 `protobuf:"varint,3,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *GroupInfo) Reset()         { *m = GroupInfo{} }
func (m *GroupInfo) String() string { return proto.CompactTextString(m) }
func (*GroupInfo) ProtoMessage()    {}
func (*GroupInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf95fa2efdc74d97, []int{2}
}
func (m *GroupInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GroupInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GroupInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GroupInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GroupInfo.Merge(m, src)
}
func (m *GroupInfo) XXX_Size() int {
	return m.Size()
}
func (m *GroupInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_GroupInfo.DiscardUnknown(m)
}

var xxx_messageInfo_GroupInfo proto.InternalMessageInfo

func (m *GroupInfo) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *GroupInfo) GetGroupName() string {
	if m != nil {
		return m.GroupName
	}
	return ""
}

func (m *GroupInfo) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

type GroupMemberInfo struct {
	GroupId    uint64 `protobuf:"varint,1,opt,name=GroupId,proto3" json:"GroupId,omitempty"`
	ExpireTime uint64 `protobuf:"varint,2,opt,name=expire_time,json=expireTime,proto3" json:"expire_time,omitempty"`
}

func (m *GroupMemberInfo) Reset()         { *m = GroupMemberInfo{} }
func (m *GroupMemberInfo) String() string { return proto.CompactTextString(m) }
func (*GroupMemberInfo) ProtoMessage()    {}
func (*GroupMemberInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf95fa2efdc74d97, []int{3}
}
func (m *GroupMemberInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GroupMemberInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GroupMemberInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GroupMemberInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GroupMemberInfo.Merge(m, src)
}
func (m *GroupMemberInfo) XXX_Size() int {
	return m.Size()
}
func (m *GroupMemberInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_GroupMemberInfo.DiscardUnknown(m)
}

var xxx_messageInfo_GroupMemberInfo proto.InternalMessageInfo

func (m *GroupMemberInfo) GetGroupId() uint64 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *GroupMemberInfo) GetExpireTime() uint64 {
	if m != nil {
		return m.ExpireTime
	}
	return 0
}

func init() {
	proto.RegisterEnum("bnbchain.greenfield.storage.ReadQuota", ReadQuota_name, ReadQuota_value)
	proto.RegisterEnum("bnbchain.greenfield.storage.RedundancyType", RedundancyType_name, RedundancyType_value)
	proto.RegisterEnum("bnbchain.greenfield.storage.ObjectStatus", ObjectStatus_name, ObjectStatus_value)
	proto.RegisterType((*BucketInfo)(nil), "bnbchain.greenfield.storage.BucketInfo")
	proto.RegisterType((*ObjectInfo)(nil), "bnbchain.greenfield.storage.ObjectInfo")
	proto.RegisterType((*GroupInfo)(nil), "bnbchain.greenfield.storage.GroupInfo")
	proto.RegisterType((*GroupMemberInfo)(nil), "bnbchain.greenfield.storage.GroupMemberInfo")
}

func init() { proto.RegisterFile("greenfield/storage/types.proto", fileDescriptor_bf95fa2efdc74d97) }

var fileDescriptor_bf95fa2efdc74d97 = []byte{
	// 783 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x55, 0x41, 0x6e, 0xdb, 0x46,
	0x14, 0x15, 0x25, 0xc5, 0x91, 0xbe, 0x14, 0x59, 0x98, 0x1a, 0x2e, 0x6b, 0xa7, 0xb2, 0xe2, 0x45,
	0xaa, 0xa6, 0x88, 0x04, 0xb4, 0x27, 0x90, 0x65, 0xa6, 0x65, 0xe0, 0xd2, 0xce, 0x90, 0x2e, 0x90,
	0x6e, 0x06, 0x43, 0x72, 0x42, 0x33, 0x31, 0x39, 0xec, 0x0c, 0x89, 0x46, 0x39, 0x41, 0x97, 0xbd,
	0x43, 0xaf, 0xd0, 0x43, 0x74, 0x19, 0x74, 0xd5, 0x65, 0x61, 0x6f, 0x7b, 0x81, 0xee, 0x0a, 0xce,
	0x50, 0x8a, 0x24, 0x14, 0x32, 0x50, 0xa0, 0xbb, 0xf9, 0x6f, 0xfe, 0x7b, 0xf3, 0xf1, 0xdf, 0x93,
	0x08, 0x83, 0x48, 0x30, 0x96, 0xbe, 0x8a, 0xd9, 0x75, 0x38, 0x91, 0x39, 0x17, 0x34, 0x62, 0x93,
	0x7c, 0x9e, 0x31, 0x39, 0xce, 0x04, 0xcf, 0x39, 0x3a, 0xf4, 0x53, 0x3f, 0xb8, 0xa2, 0x71, 0x3a,
	0xfe, 0xd0, 0x38, 0xae, 0x1a, 0x0f, 0x8e, 0xfe, 0x85, 0x1c, 0xf0, 0x24, 0xe1, 0xa9, 0x66, 0x1f,
	0x7c, 0x12, 0x70, 0x99, 0x70, 0x49, 0x54, 0x35, 0xd1, 0x45, 0x75, 0xb5, 0x17, 0xf1, 0x88, 0x6b,
	0xbc, 0x3c, 0x69, 0xf4, 0xf8, 0xef, 0x3a, 0xc0, 0x49, 0x11, 0xbc, 0x61, 0xb9, 0x9d, 0xbe, 0xe2,
	0x68, 0x0c, 0xf7, 0xf8, 0x8f, 0x29, 0x13, 0xa6, 0x31, 0x34, 0x46, 0xed, 0x13, 0xf3, 0xf7, 0x5f,
	0x9f, 0xee, 0x55, 0x2a, 0xd3, 0x30, 0x14, 0x4c, 0x4a, 0x37, 0x17, 0x71, 0x1a, 0x61, 0xdd, 0x86,
	0x8e, 0xa0, 0xe3, 0x2b, 0x36, 0x49, 0x69, 0xc2, 0xcc, 0x7a, 0xc9, 0xc2, 0xa0, 0x21, 0x87, 0x26,
	0x0c, 0x1d, 0x42, 0x3b, 0x96, 0x24, 0x2b, 0xfc, 0xeb, 0x38, 0x30, 0x1b, 0x43, 0x63, 0xd4, 0xc2,
	0xad, 0x58, 0x5e, 0xa8, 0x1a, 0xf5, 0xa0, 0x1e, 0x87, 0x66, 0x73, 0x68, 0x8c, 0x9a, 0xb8, 0x1e,
	0x87, 0x65, 0x73, 0x20, 0x18, 0xcd, 0x19, 0xa1, 0xb9, 0x79, 0x6f, 0x68, 0x8c, 0x1a, 0xb8, 0xa5,
	0x81, 0x69, 0x8e, 0xa6, 0xb0, 0x9b, 0xd1, 0x79, 0xc2, 0xd2, 0x9c, 0x50, 0x3d, 0x8a, 0xb9, 0x73,
	0xc7, 0x90, 0xbd, 0x8a, 0x50, 0xa1, 0xe8, 0x19, 0xa0, 0x4c, 0xc4, 0x09, 0x15, 0x73, 0x22, 0xb3,
	0xa5, 0xca, 0xfd, 0x3b, 0x54, 0xfa, 0x15, 0xc7, 0xcd, 0x16, 0x3a, 0x16, 0x80, 0x60, 0x34, 0x24,
	0x3f, 0x14, 0x3c, 0xa7, 0x66, 0x6b, 0x68, 0x8c, 0x7a, 0x5f, 0x3e, 0x1e, 0x6f, 0x31, 0x6e, 0x8c,
	0x19, 0x0d, 0x5f, 0x94, 0xdd, 0xb8, 0x2d, 0x16, 0xc7, 0xe3, 0xbf, 0x9a, 0x00, 0xe7, 0xfe, 0x6b,
	0x16, 0xfc, 0x4f, 0xbb, 0x3f, 0x82, 0x0e, 0x57, 0xf2, 0xba, 0xa1, 0xa1, 0x1b, 0x34, 0xa4, 0x1a,
	0x36, 0xf7, 0xff, 0x08, 0xba, 0x19, 0x9d, 0x5f, 0x73, 0x1a, 0x12, 0x19, 0xbf, 0x63, 0xca, 0x82,
	0x26, 0xee, 0x54, 0x98, 0x1b, 0xbf, 0xdb, 0xf0, 0x73, 0x67, 0xc3, 0xcf, 0x47, 0xd0, 0x0d, 0x78,
	0x9a, 0x97, 0x16, 0x95, 0x91, 0xd6, 0x9b, 0xc5, 0x9d, 0x0a, 0xf3, 0xe6, 0x19, 0x5b, 0xb7, 0xb8,
	0xb5, 0x61, 0xb1, 0x03, 0x0f, 0xaa, 0x81, 0x65, 0x4e, 0xf3, 0x42, 0x9a, 0x6d, 0xb5, 0xda, 0xcf,
	0xb7, 0xae, 0x56, 0x6f, 0xd0, 0x55, 0x04, 0xdc, 0xe5, 0x2b, 0x15, 0xf2, 0x60, 0x57, 0xb0, 0xb0,
	0x48, 0x43, 0x9a, 0x06, 0x73, 0x3d, 0x12, 0x28, 0xc5, 0x2f, 0xee, 0x30, 0x6b, 0xc1, 0x29, 0x47,
	0xc6, 0x3d, 0xb1, 0x56, 0xa3, 0x6f, 0xa0, 0x23, 0x79, 0x21, 0x02, 0xa6, 0x15, 0x3b, 0x4a, 0xf1,
	0xb3, 0xad, 0x8a, 0xae, 0xea, 0x57, 0x6a, 0x20, 0x97, 0x67, 0xf4, 0x10, 0xda, 0xc1, 0x15, 0x0b,
	0xde, 0xc8, 0x22, 0x91, 0x66, 0x77, 0xd8, 0x18, 0x75, 0xf1, 0x07, 0x00, 0x39, 0xb0, 0x2f, 0x59,
	0xc0, 0xd3, 0x70, 0x3d, 0xaf, 0x4c, 0x9a, 0x0f, 0x86, 0x8d, 0xad, 0x01, 0xd9, 0x5b, 0xf2, 0x96,
	0x99, 0x65, 0xf2, 0xf8, 0x35, 0xb4, 0xbf, 0x16, 0xbc, 0xc8, 0xfe, 0x53, 0xd8, 0x3e, 0x05, 0x88,
	0x4a, 0xf2, 0x6a, 0xd6, 0xda, 0x0a, 0x59, 0x49, 0x52, 0x63, 0x91, 0xa4, 0xe3, 0x33, 0xd8, 0x55,
	0x6f, 0x7d, 0xcb, 0x12, 0x9f, 0x09, 0xf5, 0xa2, 0x09, 0xf7, 0xf5, 0xf3, 0xa1, 0x7a, 0xb3, 0x89,
	0x17, 0x65, 0x99, 0x53, 0xf6, 0x36, 0x8b, 0x05, 0x23, 0x79, 0x5c, 0x89, 0x37, 0x31, 0x68, 0xc8,
	0x8b, 0x13, 0xf6, 0xe4, 0x31, 0xb4, 0x97, 0x3f, 0x20, 0xf4, 0x11, 0xec, 0x62, 0x6b, 0x7a, 0x4a,
	0x5e, 0x5c, 0x9e, 0x7b, 0x53, 0xf2, 0x0c, 0x5b, 0x56, 0xbf, 0x76, 0xd0, 0xfc, 0xe9, 0x97, 0x41,
	0xed, 0x49, 0x04, 0xbd, 0x75, 0xef, 0xd0, 0x21, 0x7c, 0x8c, 0xad, 0xd3, 0x4b, 0xe7, 0x74, 0xea,
	0xcc, 0x5e, 0x12, 0x6c, 0x5d, 0x9c, 0xd9, 0xb3, 0x29, 0xf1, 0x5e, 0x5e, 0x58, 0xfd, 0x1a, 0xda,
	0x07, 0xb4, 0x72, 0x69, 0xcd, 0x34, 0x6e, 0xa0, 0x03, 0xd8, 0x5f, 0xc1, 0x6d, 0xe7, 0xcc, 0x76,
	0x2c, 0x7d, 0x57, 0xaf, 0x1e, 0x7a, 0x0e, 0xdd, 0xd5, 0xd8, 0x95, 0x4a, 0xe7, 0x27, 0xcf, 0xad,
	0x99, 0x47, 0x5c, 0x6f, 0xea, 0x5d, 0xba, 0xc4, 0x76, 0x6c, 0xaf, 0x5f, 0x43, 0x0f, 0xc1, 0xdc,
	0xc4, 0x89, 0x6b, 0xe1, 0xef, 0xec, 0x99, 0xd5, 0x37, 0xb4, 0xd6, 0x89, 0xfd, 0xdb, 0xcd, 0xc0,
	0x78, 0x7f, 0x33, 0x30, 0xfe, 0xbc, 0x19, 0x18, 0x3f, 0xdf, 0x0e, 0x6a, 0xef, 0x6f, 0x07, 0xb5,
	0x3f, 0x6e, 0x07, 0xb5, 0xef, 0x27, 0x51, 0x9c, 0x5f, 0x15, 0xfe, 0x38, 0xe0, 0xc9, 0xc4, 0x4f,
	0xfd, 0xa7, 0x2a, 0x5e, 0x93, 0x95, 0x4f, 0xc0, 0xdb, 0xf5, 0x2f, 0x88, 0xbf, 0xa3, 0xfe, 0xd3,
	0xbf, 0xfa, 0x27, 0x00, 0x00, 0xff, 0xff, 0xad, 0x78, 0x9d, 0xce, 0x64, 0x06, 0x00, 0x00,
}

func (m *BucketInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BucketInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BucketInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReadQuota != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ReadQuota))
		i--
		dAtA[i] = 0x40
	}
	if len(m.PrimarySpAddress) > 0 {
		i -= len(m.PrimarySpAddress)
		copy(dAtA[i:], m.PrimarySpAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PrimarySpAddress)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.PaymentAddress) > 0 {
		i -= len(m.PaymentAddress)
		copy(dAtA[i:], m.PaymentAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PaymentAddress)))
		i--
		dAtA[i] = 0x32
	}
	if m.CreateAt != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CreateAt))
		i--
		dAtA[i] = 0x28
	}
	if m.Id != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x20
	}
	if m.IsPublic {
		i--
		if m.IsPublic {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.BucketName) > 0 {
		i -= len(m.BucketName)
		copy(dAtA[i:], m.BucketName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BucketName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ObjectInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ObjectInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SecondarySpAddresses) > 0 {
		for iNdEx := len(m.SecondarySpAddresses) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SecondarySpAddresses[iNdEx])
			copy(dAtA[i:], m.SecondarySpAddresses[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.SecondarySpAddresses[iNdEx])))
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.Checksums) > 0 {
		for iNdEx := len(m.Checksums) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Checksums[iNdEx])
			copy(dAtA[i:], m.Checksums[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Checksums[iNdEx])))
			i--
			dAtA[i] = 0x62
		}
	}
	if m.SourceType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SourceType))
		i--
		dAtA[i] = 0x58
	}
	if m.RedundancyType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.RedundancyType))
		i--
		dAtA[i] = 0x50
	}
	if m.ObjectStatus != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ObjectStatus))
		i--
		dAtA[i] = 0x48
	}
	if m.CreateAt != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CreateAt))
		i--
		dAtA[i] = 0x40
	}
	if len(m.ContentType) > 0 {
		i -= len(m.ContentType)
		copy(dAtA[i:], m.ContentType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ContentType)))
		i--
		dAtA[i] = 0x3a
	}
	if m.IsPublic {
		i--
		if m.IsPublic {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.PayloadSize != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.PayloadSize))
		i--
		dAtA[i] = 0x28
	}
	if m.Id != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x20
	}
	if len(m.ObjectName) > 0 {
		i -= len(m.ObjectName)
		copy(dAtA[i:], m.ObjectName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ObjectName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.BucketName) > 0 {
		i -= len(m.BucketName)
		copy(dAtA[i:], m.BucketName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BucketName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GroupInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GroupInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x18
	}
	if len(m.GroupName) > 0 {
		i -= len(m.GroupName)
		copy(dAtA[i:], m.GroupName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.GroupName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GroupMemberInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupMemberInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GroupMemberInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExpireTime != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ExpireTime))
		i--
		dAtA[i] = 0x10
	}
	if m.GroupId != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *BucketInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.BucketName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.IsPublic {
		n += 2
	}
	if m.Id != 0 {
		n += 1 + sovTypes(uint64(m.Id))
	}
	if m.CreateAt != 0 {
		n += 1 + sovTypes(uint64(m.CreateAt))
	}
	l = len(m.PaymentAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PrimarySpAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ReadQuota != 0 {
		n += 1 + sovTypes(uint64(m.ReadQuota))
	}
	return n
}

func (m *ObjectInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.BucketName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ObjectName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Id != 0 {
		n += 1 + sovTypes(uint64(m.Id))
	}
	if m.PayloadSize != 0 {
		n += 1 + sovTypes(uint64(m.PayloadSize))
	}
	if m.IsPublic {
		n += 2
	}
	l = len(m.ContentType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CreateAt != 0 {
		n += 1 + sovTypes(uint64(m.CreateAt))
	}
	if m.ObjectStatus != 0 {
		n += 1 + sovTypes(uint64(m.ObjectStatus))
	}
	if m.RedundancyType != 0 {
		n += 1 + sovTypes(uint64(m.RedundancyType))
	}
	if m.SourceType != 0 {
		n += 1 + sovTypes(uint64(m.SourceType))
	}
	if len(m.Checksums) > 0 {
		for _, b := range m.Checksums {
			l = len(b)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.SecondarySpAddresses) > 0 {
		for _, s := range m.SecondarySpAddresses {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *GroupInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.GroupName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Id != 0 {
		n += 1 + sovTypes(uint64(m.Id))
	}
	return n
}

func (m *GroupMemberInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupId != 0 {
		n += 1 + sovTypes(uint64(m.GroupId))
	}
	if m.ExpireTime != 0 {
		n += 1 + sovTypes(uint64(m.ExpireTime))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *BucketInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BucketInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BucketInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BucketName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BucketName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPublic", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPublic = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
			}
			m.CreateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PaymentAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimarySpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrimarySpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadQuota", wireType)
			}
			m.ReadQuota = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadQuota |= ReadQuota(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BucketName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BucketName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadSize", wireType)
			}
			m.PayloadSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PayloadSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPublic", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPublic = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
			}
			m.CreateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectStatus", wireType)
			}
			m.ObjectStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjectStatus |= ObjectStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedundancyType", wireType)
			}
			m.RedundancyType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RedundancyType |= RedundancyType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceType", wireType)
			}
			m.SourceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceType |= SourceType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checksums", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Checksums = append(m.Checksums, make([]byte, postIndex-iNdEx))
			copy(m.Checksums[len(m.Checksums)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecondarySpAddresses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecondarySpAddresses = append(m.SecondarySpAddresses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupMemberInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupMemberInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupMemberInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpireTime", wireType)
			}
			m.ExpireTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpireTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
