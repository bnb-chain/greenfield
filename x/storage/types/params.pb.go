// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: greenfield/storage/params.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Params defines the parameters for the module.
type Params struct {
	VersionedParams VersionedParams `protobuf:"bytes,1,opt,name=versioned_params,json=versionedParams,proto3" json:"versioned_params"`
	// max_payload_size is the maximum size of the payload, default: 2G
	MaxPayloadSize uint64 `protobuf:"varint,2,opt,name=max_payload_size,json=maxPayloadSize,proto3" json:"max_payload_size,omitempty"`
	// relayer fee for the mirror bucket tx
	MirrorBucketRelayerFee string `protobuf:"bytes,3,opt,name=mirror_bucket_relayer_fee,json=mirrorBucketRelayerFee,proto3" json:"mirror_bucket_relayer_fee,omitempty"`
	// relayer fee for the ACK or FAIL_ACK package of the mirror bucket tx
	MirrorBucketAckRelayerFee string `protobuf:"bytes,4,opt,name=mirror_bucket_ack_relayer_fee,json=mirrorBucketAckRelayerFee,proto3" json:"mirror_bucket_ack_relayer_fee,omitempty"`
	// relayer fee for the mirror object tx
	MirrorObjectRelayerFee string `protobuf:"bytes,5,opt,name=mirror_object_relayer_fee,json=mirrorObjectRelayerFee,proto3" json:"mirror_object_relayer_fee,omitempty"`
	// Relayer fee for the ACK or FAIL_ACK package of the mirror object tx
	MirrorObjectAckRelayerFee string `protobuf:"bytes,6,opt,name=mirror_object_ack_relayer_fee,json=mirrorObjectAckRelayerFee,proto3" json:"mirror_object_ack_relayer_fee,omitempty"`
	// relayer fee for the mirror object tx
	MirrorGroupRelayerFee string `protobuf:"bytes,7,opt,name=mirror_group_relayer_fee,json=mirrorGroupRelayerFee,proto3" json:"mirror_group_relayer_fee,omitempty"`
	// Relayer fee for the ACK or FAIL_ACK package of the mirror object tx
	MirrorGroupAckRelayerFee string `protobuf:"bytes,8,opt,name=mirror_group_ack_relayer_fee,json=mirrorGroupAckRelayerFee,proto3" json:"mirror_group_ack_relayer_fee,omitempty"`
	// The maximum number of buckets that can be created per account
	MaxBucketsPerAccount uint32 `protobuf:"varint,9,opt,name=max_buckets_per_account,json=maxBucketsPerAccount,proto3" json:"max_buckets_per_account,omitempty"`
	// The window to count the discontinued objects or buckets
	DiscontinueCountingWindow uint64 `protobuf:"varint,10,opt,name=discontinue_counting_window,json=discontinueCountingWindow,proto3" json:"discontinue_counting_window,omitempty"`
	// The max objects can be requested in a window
	DiscontinueObjectMax uint64 `protobuf:"varint,11,opt,name=discontinue_object_max,json=discontinueObjectMax,proto3" json:"discontinue_object_max,omitempty"`
	// The max buckets can be requested in a window
	DiscontinueBucketMax uint64 `protobuf:"varint,12,opt,name=discontinue_bucket_max,json=discontinueBucketMax,proto3" json:"discontinue_bucket_max,omitempty"`
	// The object will be deleted after the confirm period in seconds
	DiscontinueConfirmPeriod int64 `protobuf:"varint,13,opt,name=discontinue_confirm_period,json=discontinueConfirmPeriod,proto3" json:"discontinue_confirm_period,omitempty"`
	// The max delete objects in each end block
	DiscontinueDeletionMax uint64 `protobuf:"varint,14,opt,name=discontinue_deletion_max,json=discontinueDeletionMax,proto3" json:"discontinue_deletion_max,omitempty"`
	// The max number for deleting policy in each end block
	StalePolicyCleanupMax uint64 `protobuf:"varint,15,opt,name=stale_policy_cleanup_max,json=stalePolicyCleanupMax,proto3" json:"stale_policy_cleanup_max,omitempty"`
	// The min interval for making quota smaller in seconds
	MinQuotaUpdateInterval uint64 `protobuf:"varint,16,opt,name=min_quota_update_interval,json=minQuotaUpdateInterval,proto3" json:"min_quota_update_interval,omitempty"`
}

func (m *Params) Reset()      { *m = Params{} }
func (*Params) ProtoMessage() {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_127b8b1511d84eca, []int{0}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetVersionedParams() VersionedParams {
	if m != nil {
		return m.VersionedParams
	}
	return VersionedParams{}
}

func (m *Params) GetMaxPayloadSize() uint64 {
	if m != nil {
		return m.MaxPayloadSize
	}
	return 0
}

func (m *Params) GetMirrorBucketRelayerFee() string {
	if m != nil {
		return m.MirrorBucketRelayerFee
	}
	return ""
}

func (m *Params) GetMirrorBucketAckRelayerFee() string {
	if m != nil {
		return m.MirrorBucketAckRelayerFee
	}
	return ""
}

func (m *Params) GetMirrorObjectRelayerFee() string {
	if m != nil {
		return m.MirrorObjectRelayerFee
	}
	return ""
}

func (m *Params) GetMirrorObjectAckRelayerFee() string {
	if m != nil {
		return m.MirrorObjectAckRelayerFee
	}
	return ""
}

func (m *Params) GetMirrorGroupRelayerFee() string {
	if m != nil {
		return m.MirrorGroupRelayerFee
	}
	return ""
}

func (m *Params) GetMirrorGroupAckRelayerFee() string {
	if m != nil {
		return m.MirrorGroupAckRelayerFee
	}
	return ""
}

func (m *Params) GetMaxBucketsPerAccount() uint32 {
	if m != nil {
		return m.MaxBucketsPerAccount
	}
	return 0
}

func (m *Params) GetDiscontinueCountingWindow() uint64 {
	if m != nil {
		return m.DiscontinueCountingWindow
	}
	return 0
}

func (m *Params) GetDiscontinueObjectMax() uint64 {
	if m != nil {
		return m.DiscontinueObjectMax
	}
	return 0
}

func (m *Params) GetDiscontinueBucketMax() uint64 {
	if m != nil {
		return m.DiscontinueBucketMax
	}
	return 0
}

func (m *Params) GetDiscontinueConfirmPeriod() int64 {
	if m != nil {
		return m.DiscontinueConfirmPeriod
	}
	return 0
}

func (m *Params) GetDiscontinueDeletionMax() uint64 {
	if m != nil {
		return m.DiscontinueDeletionMax
	}
	return 0
}

func (m *Params) GetStalePolicyCleanupMax() uint64 {
	if m != nil {
		return m.StalePolicyCleanupMax
	}
	return 0
}

func (m *Params) GetMinQuotaUpdateInterval() uint64 {
	if m != nil {
		return m.MinQuotaUpdateInterval
	}
	return 0
}

// VersionedParams defines the parameters for the storage module with multi version, each version store with different timestamp.
type VersionedParams struct {
	// max_segment_size is the maximum size of a segment. default: 16M
	MaxSegmentSize uint64 `protobuf:"varint,1,opt,name=max_segment_size,json=maxSegmentSize,proto3" json:"max_segment_size,omitempty"`
	// redundant_data_check_num is the num of data chunks of EC redundancy algorithm
	RedundantDataChunkNum uint32 `protobuf:"varint,2,opt,name=redundant_data_chunk_num,json=redundantDataChunkNum,proto3" json:"redundant_data_chunk_num,omitempty"`
	// redundant_data_check_num is the num of parity chunks of EC redundancy algorithm
	RedundantParityChunkNum uint32 `protobuf:"varint,3,opt,name=redundant_parity_chunk_num,json=redundantParityChunkNum,proto3" json:"redundant_parity_chunk_num,omitempty"`
	// min_charge_size is the minimum charge size of the payload, objects smaller than this size will be charged as this size
	MinChargeSize uint64 `protobuf:"varint,4,opt,name=min_charge_size,json=minChargeSize,proto3" json:"min_charge_size,omitempty"`
}

func (m *VersionedParams) Reset()      { *m = VersionedParams{} }
func (*VersionedParams) ProtoMessage() {}
func (*VersionedParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_127b8b1511d84eca, []int{1}
}
func (m *VersionedParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VersionedParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VersionedParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VersionedParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VersionedParams.Merge(m, src)
}
func (m *VersionedParams) XXX_Size() int {
	return m.Size()
}
func (m *VersionedParams) XXX_DiscardUnknown() {
	xxx_messageInfo_VersionedParams.DiscardUnknown(m)
}

var xxx_messageInfo_VersionedParams proto.InternalMessageInfo

func (m *VersionedParams) GetMaxSegmentSize() uint64 {
	if m != nil {
		return m.MaxSegmentSize
	}
	return 0
}

func (m *VersionedParams) GetRedundantDataChunkNum() uint32 {
	if m != nil {
		return m.RedundantDataChunkNum
	}
	return 0
}

func (m *VersionedParams) GetRedundantParityChunkNum() uint32 {
	if m != nil {
		return m.RedundantParityChunkNum
	}
	return 0
}

func (m *VersionedParams) GetMinChargeSize() uint64 {
	if m != nil {
		return m.MinChargeSize
	}
	return 0
}

func init() {
	proto.RegisterType((*Params)(nil), "greenfield.storage.Params")
	proto.RegisterType((*VersionedParams)(nil), "greenfield.storage.VersionedParams")
}

func init() { proto.RegisterFile("greenfield/storage/params.proto", fileDescriptor_127b8b1511d84eca) }

var fileDescriptor_127b8b1511d84eca = []byte{
	// 687 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x94, 0x4d, 0x4f, 0xdb, 0x4a,
	0x14, 0x86, 0xe3, 0x4b, 0x2e, 0x5c, 0x86, 0x1b, 0x82, 0x2c, 0x3e, 0x0c, 0xf7, 0x36, 0x44, 0x54,
	0xaa, 0xb2, 0x69, 0x22, 0xf5, 0x43, 0xf4, 0x4b, 0xa8, 0x10, 0xd4, 0x8a, 0x45, 0xdb, 0xd4, 0xb4,
	0x54, 0xea, 0x66, 0x34, 0xb1, 0x0f, 0xce, 0x34, 0xf6, 0x8c, 0x3b, 0x1e, 0x43, 0xc2, 0xaf, 0xe8,
	0xb2, 0xcb, 0xfe, 0x1c, 0x96, 0x2c, 0xbb, 0x6a, 0x2b, 0xf8, 0x23, 0x95, 0xcf, 0xb8, 0xc1, 0x06,
	0x76, 0xd6, 0x79, 0xdf, 0x67, 0xde, 0x33, 0x33, 0x3e, 0x43, 0xd6, 0x03, 0x05, 0x20, 0x0e, 0x39,
	0x84, 0x7e, 0x27, 0xd1, 0x52, 0xb1, 0x00, 0x3a, 0x31, 0x53, 0x2c, 0x4a, 0xda, 0xb1, 0x92, 0x5a,
	0xda, 0xf6, 0xa5, 0xa1, 0x9d, 0x1b, 0xd6, 0x16, 0x03, 0x19, 0x48, 0x94, 0x3b, 0xd9, 0x97, 0x71,
	0x6e, 0x9c, 0xcd, 0x90, 0xe9, 0x1e, 0xa2, 0xf6, 0x3b, 0xb2, 0x70, 0x04, 0x2a, 0xe1, 0x52, 0x80,
	0x4f, 0xcd, 0x72, 0x8e, 0xd5, 0xb4, 0x5a, 0x73, 0xf7, 0x6e, 0xb7, 0xaf, 0xaf, 0xd7, 0x3e, 0xf8,
	0xe3, 0x35, 0xf8, 0x4e, 0xf5, 0xf4, 0xc7, 0x7a, 0xc5, 0xad, 0x1f, 0x95, 0xcb, 0x76, 0x8b, 0x2c,
	0x44, 0x6c, 0x44, 0x63, 0x36, 0x0e, 0x25, 0xf3, 0x69, 0xc2, 0x4f, 0xc0, 0xf9, 0xab, 0x69, 0xb5,
	0xaa, 0xee, 0x7c, 0xc4, 0x46, 0x3d, 0x53, 0xde, 0xe7, 0x27, 0x60, 0x3f, 0x26, 0xab, 0x11, 0x57,
	0x4a, 0x2a, 0xda, 0x4f, 0xbd, 0x21, 0x68, 0xaa, 0x20, 0x64, 0x63, 0x50, 0xf4, 0x10, 0xc0, 0x99,
	0x6a, 0x5a, 0xad, 0x59, 0x77, 0xd9, 0x18, 0x76, 0x50, 0x77, 0x8d, 0xfc, 0x02, 0xc0, 0x7e, 0x4e,
	0x6e, 0x95, 0x51, 0xe6, 0x0d, 0x4b, 0x78, 0x15, 0xf1, 0xd5, 0x22, 0xbe, 0xed, 0x0d, 0x0b, 0x2b,
	0x5c, 0x86, 0xcb, 0xfe, 0x27, 0xf0, 0xca, 0xe1, 0x7f, 0x17, 0xc3, 0xdf, 0xa0, 0x7e, 0x63, 0x78,
	0x8e, 0x5e, 0x0d, 0x9f, 0x2e, 0x86, 0x1b, 0xbc, 0x1c, 0xbe, 0x49, 0x9c, 0x7c, 0x85, 0x40, 0xc9,
	0x34, 0x2e, 0xc1, 0x33, 0x08, 0x2f, 0x19, 0xfd, 0x65, 0x26, 0x17, 0xc0, 0x2d, 0xf2, 0x7f, 0x09,
	0xbc, 0x9a, 0xfc, 0x0f, 0xc2, 0x4e, 0x01, 0x2e, 0x07, 0x3f, 0x24, 0x2b, 0xd9, 0xe5, 0x98, 0x43,
	0x4b, 0x68, 0x0c, 0x8a, 0x32, 0xcf, 0x93, 0xa9, 0xd0, 0xce, 0x6c, 0xd3, 0x6a, 0xd5, 0xdc, 0xc5,
	0x88, 0x8d, 0xcc, 0x71, 0x25, 0x3d, 0x50, 0xdb, 0x46, 0xb3, 0xb7, 0xc8, 0x7f, 0x3e, 0x4f, 0x3c,
	0x29, 0x34, 0x17, 0x29, 0x50, 0x2c, 0x72, 0x11, 0xd0, 0x63, 0x2e, 0x7c, 0x79, 0xec, 0x10, 0xbc,
	0xde, 0xd5, 0x82, 0xa5, 0x9b, 0x3b, 0x3e, 0xa0, 0xc1, 0x7e, 0x40, 0x96, 0x8b, 0x7c, 0x7e, 0x6c,
	0x11, 0x1b, 0x39, 0x73, 0x88, 0x2e, 0x16, 0x54, 0x73, 0x5e, 0xaf, 0xd8, 0xe8, 0x2a, 0x95, 0xdf,
	0x74, 0x46, 0xfd, 0x7b, 0x8d, 0x32, 0x3d, 0x67, 0xd4, 0x33, 0xb2, 0x56, 0xee, 0x55, 0x1c, 0x72,
	0x15, 0x65, 0x5b, 0xe5, 0xd2, 0x77, 0x6a, 0x4d, 0xab, 0x35, 0xe5, 0x3a, 0xa5, 0x56, 0xd1, 0xd0,
	0x43, 0xdd, 0x7e, 0x44, 0x8a, 0x1a, 0xf5, 0x21, 0x04, 0xcd, 0xa5, 0xc0, 0xd4, 0x79, 0x4c, 0x2d,
	0xf6, 0xb4, 0x9b, 0xcb, 0x59, 0xee, 0x26, 0x71, 0x12, 0xcd, 0x42, 0xa0, 0xb1, 0x0c, 0xb9, 0x37,
	0xa6, 0x5e, 0x08, 0x4c, 0xa4, 0x31, 0x92, 0x75, 0x24, 0x97, 0x50, 0xef, 0xa1, 0xdc, 0x35, 0x6a,
	0x06, 0xe2, 0x9f, 0x28, 0xe8, 0xe7, 0x54, 0x6a, 0x46, 0xd3, 0xd8, 0x67, 0x1a, 0x28, 0x17, 0x1a,
	0xd4, 0x11, 0x0b, 0x9d, 0x05, 0x93, 0x19, 0x71, 0xf1, 0x36, 0xd3, 0xdf, 0xa3, 0xbc, 0x97, 0xab,
	0x4f, 0xaa, 0x5f, 0xbf, 0xad, 0x57, 0x36, 0x7e, 0x5a, 0xa4, 0x7e, 0x70, 0xf3, 0x14, 0x26, 0x10,
	0x44, 0x20, 0xb4, 0x99, 0x42, 0x6b, 0x32, 0x85, 0xfb, 0xa6, 0x8c, 0x53, 0xb8, 0x49, 0x1c, 0x05,
	0x7e, 0x2a, 0x7c, 0x26, 0x34, 0xf5, 0x99, 0x66, 0xd4, 0x1b, 0xa4, 0x62, 0x48, 0x45, 0x1a, 0xe1,
	0xdc, 0xd6, 0xdc, 0xa5, 0x89, 0xbe, 0xcb, 0x34, 0xeb, 0x66, 0xea, 0xeb, 0x34, 0xb2, 0x9f, 0x92,
	0xb5, 0x4b, 0x30, 0x66, 0x8a, 0xeb, 0x71, 0x01, 0x9d, 0x42, 0x74, 0x65, 0xe2, 0xe8, 0xa1, 0x61,
	0x02, 0xdf, 0x21, 0xf5, 0x6c, 0xd3, 0xde, 0x80, 0xa9, 0x00, 0x4c, 0x7b, 0x55, 0x6c, 0xaf, 0x16,
	0x71, 0xd1, 0xc5, 0x6a, 0xd6, 0x9d, 0xd9, 0xe1, 0xce, 0xde, 0xe9, 0x79, 0xc3, 0x3a, 0x3b, 0x6f,
	0x58, 0xbf, 0xce, 0x1b, 0xd6, 0x97, 0x8b, 0x46, 0xe5, 0xec, 0xa2, 0x51, 0xf9, 0x7e, 0xd1, 0xa8,
	0x7c, 0xec, 0x04, 0x5c, 0x0f, 0xd2, 0x7e, 0xdb, 0x93, 0x51, 0xa7, 0x2f, 0xfa, 0x77, 0xbd, 0x01,
	0xe3, 0xa2, 0x53, 0x78, 0x2e, 0x47, 0x93, 0x07, 0x53, 0x8f, 0x63, 0x48, 0xfa, 0xd3, 0xf8, 0x0c,
	0xde, 0xff, 0x1d, 0x00, 0x00, 0xff, 0xff, 0xf9, 0xde, 0x9a, 0xf5, 0x53, 0x05, 0x00, 0x00,
}

func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MinQuotaUpdateInterval != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.MinQuotaUpdateInterval))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.StalePolicyCleanupMax != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.StalePolicyCleanupMax))
		i--
		dAtA[i] = 0x78
	}
	if m.DiscontinueDeletionMax != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.DiscontinueDeletionMax))
		i--
		dAtA[i] = 0x70
	}
	if m.DiscontinueConfirmPeriod != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.DiscontinueConfirmPeriod))
		i--
		dAtA[i] = 0x68
	}
	if m.DiscontinueBucketMax != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.DiscontinueBucketMax))
		i--
		dAtA[i] = 0x60
	}
	if m.DiscontinueObjectMax != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.DiscontinueObjectMax))
		i--
		dAtA[i] = 0x58
	}
	if m.DiscontinueCountingWindow != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.DiscontinueCountingWindow))
		i--
		dAtA[i] = 0x50
	}
	if m.MaxBucketsPerAccount != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.MaxBucketsPerAccount))
		i--
		dAtA[i] = 0x48
	}
	if len(m.MirrorGroupAckRelayerFee) > 0 {
		i -= len(m.MirrorGroupAckRelayerFee)
		copy(dAtA[i:], m.MirrorGroupAckRelayerFee)
		i = encodeVarintParams(dAtA, i, uint64(len(m.MirrorGroupAckRelayerFee)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.MirrorGroupRelayerFee) > 0 {
		i -= len(m.MirrorGroupRelayerFee)
		copy(dAtA[i:], m.MirrorGroupRelayerFee)
		i = encodeVarintParams(dAtA, i, uint64(len(m.MirrorGroupRelayerFee)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.MirrorObjectAckRelayerFee) > 0 {
		i -= len(m.MirrorObjectAckRelayerFee)
		copy(dAtA[i:], m.MirrorObjectAckRelayerFee)
		i = encodeVarintParams(dAtA, i, uint64(len(m.MirrorObjectAckRelayerFee)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.MirrorObjectRelayerFee) > 0 {
		i -= len(m.MirrorObjectRelayerFee)
		copy(dAtA[i:], m.MirrorObjectRelayerFee)
		i = encodeVarintParams(dAtA, i, uint64(len(m.MirrorObjectRelayerFee)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.MirrorBucketAckRelayerFee) > 0 {
		i -= len(m.MirrorBucketAckRelayerFee)
		copy(dAtA[i:], m.MirrorBucketAckRelayerFee)
		i = encodeVarintParams(dAtA, i, uint64(len(m.MirrorBucketAckRelayerFee)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.MirrorBucketRelayerFee) > 0 {
		i -= len(m.MirrorBucketRelayerFee)
		copy(dAtA[i:], m.MirrorBucketRelayerFee)
		i = encodeVarintParams(dAtA, i, uint64(len(m.MirrorBucketRelayerFee)))
		i--
		dAtA[i] = 0x1a
	}
	if m.MaxPayloadSize != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.MaxPayloadSize))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.VersionedParams.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *VersionedParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VersionedParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VersionedParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MinChargeSize != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.MinChargeSize))
		i--
		dAtA[i] = 0x20
	}
	if m.RedundantParityChunkNum != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.RedundantParityChunkNum))
		i--
		dAtA[i] = 0x18
	}
	if m.RedundantDataChunkNum != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.RedundantDataChunkNum))
		i--
		dAtA[i] = 0x10
	}
	if m.MaxSegmentSize != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.MaxSegmentSize))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintParams(dAtA []byte, offset int, v uint64) int {
	offset -= sovParams(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.VersionedParams.Size()
	n += 1 + l + sovParams(uint64(l))
	if m.MaxPayloadSize != 0 {
		n += 1 + sovParams(uint64(m.MaxPayloadSize))
	}
	l = len(m.MirrorBucketRelayerFee)
	if l > 0 {
		n += 1 + l + sovParams(uint64(l))
	}
	l = len(m.MirrorBucketAckRelayerFee)
	if l > 0 {
		n += 1 + l + sovParams(uint64(l))
	}
	l = len(m.MirrorObjectRelayerFee)
	if l > 0 {
		n += 1 + l + sovParams(uint64(l))
	}
	l = len(m.MirrorObjectAckRelayerFee)
	if l > 0 {
		n += 1 + l + sovParams(uint64(l))
	}
	l = len(m.MirrorGroupRelayerFee)
	if l > 0 {
		n += 1 + l + sovParams(uint64(l))
	}
	l = len(m.MirrorGroupAckRelayerFee)
	if l > 0 {
		n += 1 + l + sovParams(uint64(l))
	}
	if m.MaxBucketsPerAccount != 0 {
		n += 1 + sovParams(uint64(m.MaxBucketsPerAccount))
	}
	if m.DiscontinueCountingWindow != 0 {
		n += 1 + sovParams(uint64(m.DiscontinueCountingWindow))
	}
	if m.DiscontinueObjectMax != 0 {
		n += 1 + sovParams(uint64(m.DiscontinueObjectMax))
	}
	if m.DiscontinueBucketMax != 0 {
		n += 1 + sovParams(uint64(m.DiscontinueBucketMax))
	}
	if m.DiscontinueConfirmPeriod != 0 {
		n += 1 + sovParams(uint64(m.DiscontinueConfirmPeriod))
	}
	if m.DiscontinueDeletionMax != 0 {
		n += 1 + sovParams(uint64(m.DiscontinueDeletionMax))
	}
	if m.StalePolicyCleanupMax != 0 {
		n += 1 + sovParams(uint64(m.StalePolicyCleanupMax))
	}
	if m.MinQuotaUpdateInterval != 0 {
		n += 2 + sovParams(uint64(m.MinQuotaUpdateInterval))
	}
	return n
}

func (m *VersionedParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MaxSegmentSize != 0 {
		n += 1 + sovParams(uint64(m.MaxSegmentSize))
	}
	if m.RedundantDataChunkNum != 0 {
		n += 1 + sovParams(uint64(m.RedundantDataChunkNum))
	}
	if m.RedundantParityChunkNum != 0 {
		n += 1 + sovParams(uint64(m.RedundantParityChunkNum))
	}
	if m.MinChargeSize != 0 {
		n += 1 + sovParams(uint64(m.MinChargeSize))
	}
	return n
}

func sovParams(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozParams(x uint64) (n int) {
	return sovParams(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowParams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionedParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.VersionedParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxPayloadSize", wireType)
			}
			m.MaxPayloadSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxPayloadSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MirrorBucketRelayerFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MirrorBucketRelayerFee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MirrorBucketAckRelayerFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MirrorBucketAckRelayerFee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MirrorObjectRelayerFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MirrorObjectRelayerFee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MirrorObjectAckRelayerFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MirrorObjectAckRelayerFee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MirrorGroupRelayerFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MirrorGroupRelayerFee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MirrorGroupAckRelayerFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MirrorGroupAckRelayerFee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxBucketsPerAccount", wireType)
			}
			m.MaxBucketsPerAccount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxBucketsPerAccount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscontinueCountingWindow", wireType)
			}
			m.DiscontinueCountingWindow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiscontinueCountingWindow |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscontinueObjectMax", wireType)
			}
			m.DiscontinueObjectMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiscontinueObjectMax |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscontinueBucketMax", wireType)
			}
			m.DiscontinueBucketMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiscontinueBucketMax |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscontinueConfirmPeriod", wireType)
			}
			m.DiscontinueConfirmPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiscontinueConfirmPeriod |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscontinueDeletionMax", wireType)
			}
			m.DiscontinueDeletionMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiscontinueDeletionMax |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StalePolicyCleanupMax", wireType)
			}
			m.StalePolicyCleanupMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StalePolicyCleanupMax |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinQuotaUpdateInterval", wireType)
			}
			m.MinQuotaUpdateInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinQuotaUpdateInterval |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipParams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthParams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VersionedParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowParams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VersionedParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VersionedParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSegmentSize", wireType)
			}
			m.MaxSegmentSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxSegmentSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedundantDataChunkNum", wireType)
			}
			m.RedundantDataChunkNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RedundantDataChunkNum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedundantParityChunkNum", wireType)
			}
			m.RedundantParityChunkNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RedundantParityChunkNum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinChargeSize", wireType)
			}
			m.MinChargeSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinChargeSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipParams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthParams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipParams(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowParams
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowParams
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowParams
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthParams
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupParams
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthParams
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthParams        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowParams          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupParams = fmt.Errorf("proto: unexpected end of group")
)
